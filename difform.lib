////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
version="version difform.lib 1.0.0.5 Aug_2015";
category="Noncommutative";
info="
LIBRARY:    difform.lib Procedures for differential forms
AUTHOR:     Peter Chini, chini@rhrk.uni-kl.de

OVERVIEW: 
A library for computing with elements of the differential algebra over a (quotient) ring.
To compute in this algebra, a non-commutative ring with additional variables
dx_1,...,dx_n and 'exterior' relations between this variables is used. In the case of a 
quotient ring, the defining ideal and its image under the universal derivation are added as relations.
The differential forms themselves are defined via two additional types: 'difvar' and 'difform'. Objects
of type 'difvar' represent the basic differential forms dx_1,...,dx_n and make them available over the 
basering. For more general differential forms, the type 'difform' is used: it carries a polynomial in the
differential algebra which represents the differential form. For computing with differential forms, 
most arithmetic operations and basic procedures were implemented.
Additionally, the universal derivation is available as a procedure and can be applied to
differential forms or polynomials.

The library also supports derivations: linear maps from the first graded part of the differential algebra
to the basering. These are defined via the type 'derivation' and there are procedures for basic arithmetic
operations, evaluation and Lie-derivative.

KEYWORDS: differential forms;differential;differential algebra;differential module;derivation;

TYPES:
    difvar;         type for the variables dx_i
    difform;        general differential forms
    derivation;     maps from Omega_R^1 to the basering R

PROCEDURES:

    /* diffAlgebra procedures */
    diffAlgebra();                  provides the differential algebra structure and the differential forms dx_1,...,dx_n   
    diffAlgebraRelations();     returns the relation ideal of the differential algebra as list of differential forms  
    diffAlgebraListGens(int);   returns a list of the generators of the differential algebra or of a graded part of it
    
    diffAlgenraIntToDual(int);      translates an integer to a dual number
    diffAlgebraGenToDual(difform);  computes the dual number representation of a generator
    diffAlgebraDualToGen(list);     computes the generator of a given dual number representation
    diffAlgebraDualToIntvec(list);  casts a dual number representation from list form into intvec form
    diffAlgebraIntvecToDual(list);  transorms a given intvec into a list, representing a dual number
    
    /* difform procedures */
    difformFromType(def);           constructs differential forms from arbitrary given type
    difformToString(difform);       casts a differential form to a string
    difformToVector(difform);       translates a general differential form to a vector
    difformFromVector(vector);      translates a general vector to a differential form
    
    difformCoef(difform);           computes the representation as a linear combination of the generators
    difformCoefIntvec(difform);     generates a list as in difformCoef but represents the generators as intvecs
    difformPrint(difform);          prints differential forms
    difformIsGen(difform);          decides, whether a given differential form is a generator of the differential algebra
    difformImap(ring,difform);      transport a differential form over the given ring to the basering using imap
    difformFetch(ring,difform);     transport a differential form over the given ring to the basering using fetch
    
    difformAdd(difform,difform);        adds two differential forms
    difformSub(difform,difform);        subtracts one differential form from the other
    difformNeg(difform);                returns the negative of a differential form
    difformMul(difform,difform);        multiplies two differential forms
    difformPow(difform,int);            computes the power of a differential form by a given int
    difformDiv(difform,difform);        computes the quotient of two differential forms
    difformEqu(difform,difform);        compares two differential forms
    difformNeq(difform,difform);        returns the negation of comparing two differential forms
    difformIsBigger(difform,difform);   tests if a given differential form is greater than another one
    difformIsSmaller(difform,difform);  tests if a given differential form is smaller than another one
    difformReduce(difform);             reduces a given differential form by the relation ideal of the differential algebra
    
    difformDeg(difform);            returns the degree of a given differential form
    difformIsHomog(difform);        checks if the given differential form is homogeneous
    difformIsHomogDeg(difform,int); checks if the given differential form is homogeneous of given degree
    difformHomogDec(difform);       computes the homogeneous decomposition of a differential form
    
    difformListContains(list,difform);  checks if a given differential form is in a given list and optionally returns the index
    difformListSort(list);              sorts lists of differential forms and special lists of lists
    
    difformUnivDer(difform);    computes the image of an polynomial under the universal derivation
    difformDiff(difform);       computes the image of an differential form under the differential

    /* derivation procedures */
    derivationFromType(def);        constructs a derivation from arbitrary given type
    derivationToString(derivation); casts a derivation to a string
    derivationPrint(derivation);    prints a derivation

    derivationAdd(derivation,derivation);   computes the sum of two derivations
    derivationSub(derivation,derivation);   subtracts two derivations
    derivationNeg(derivation);              negates a given derivation
    derivationMul(poly,derivation);         multiplies a polynomial and a derivation
    derivationEqu(derivation,derivation);   compares two derivations
    derivationNeq(derivation,derivation);   returns the negation of comparing two derivations
    derivationEval(derivation,difform);     evaluates a derivation at a given differential form of degree 1

    difformContraction(derivation,difform); computes the contraction and applies it to a differential form
    difformLieDer(derivation,difform);      returns the Lie-derivative applied to a differential form

";
////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
//                                  Initialization of library                                 //
////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////


static proc mod_init()
{

    // Type for the dx_i - consider them as ring-independent strings
    newstruct("difvar", "string dvar");

	// Type of differential forms:
	// These are considered as elements (polynomials) in the differential algebra
    // NOTE: the polynomials 'form' are not visible in the basering - only in the differential algebra
	newstruct("difform", "poly form");
    
    // Type of derivations - these are maps: Omega_R^1 -> R
    // The maps are uniquely determined by the images of the R-generators of Omega_R^1: dx_1,...,dx_n
    // A derivation consists of a list of two lists: genIm[1][i] is a generator and genIm[2][i] the image of it
    // The list of generators is always ordered by the ordering given on the differential algebra
    newstruct("derivation", "list genIm");

    // Overloads for difvar
    system("install", "difvar", "print", difformPrint, 1);
    
    system("install", "difvar", "+", difformAdd, 2);
	system("install", "difvar", "-", difformSub, 2);
	system("install", "difvar", "-", difformNeg, 1);
	system("install", "difvar", "*", difformMul, 2);
    system("install", "difvar", "^", difformPow, 2);
    system("install", "difvar", "/", difformDiv, 2);
	system("install", "difvar", "==", difformEqu, 2);
	system("install", "difvar", "<>", difformNeq, 2);
    system("install", "difvar", ">", difformIsBigger,2);
    system("install", "difvar", "<", difformIsSmaller,2);
    
    system("install", "difvar", "deg", difformDeg, 1);
    system("install", "difvar", "homog", difformIsHomog, 1);
    
	// Overloads for difform
	system("install", "difform", "=", difformFromType, 1);
	system("install", "difform", "print", difformPrint, 1);
    system("install", "difform", "imap", difformImap, 2);
    system("install", "difform", "fetch", difformFetch, 4);
    
	system("install", "difform", "+", difformAdd, 2);
	system("install", "difform", "-", difformSub, 2);
	system("install", "difform", "-", difformNeg, 1);
	system("install", "difform", "*", difformMul, 2);
    system("install", "difform", "^", difformPow, 2);
    system("install", "difform", "/", difformDiv, 2);
	system("install", "difform", "==", difformEqu, 2);
	system("install", "difform", "<>", difformNeq, 2);
    system("install", "difform", ">", difformIsBigger,2);
    system("install", "difform", "<", difformIsSmaller,2);
    
	system("install", "difform", "deg", difformDeg, 1);
    system("install", "difform", "homog", difformIsHomog, 1);

    // Overloads for derivation
    system("install", "derivation", "=", derivationFromType, 1);
    system("install", "derivation", "print", derivationPrint, 1);
    
    system("install", "derivation", "+", derivationAdd, 2);
    system("install", "derivation", "-", derivationSub, 2);
    system("install", "derivation", "-", derivationNeg, 1);
    system("install", "derivation", "*", derivationMul, 2);
    system("install", "derivation", "==", derivationEqu, 2);
    system("install", "derivation", "<>", derivationNeq, 2);   
    system("install", "derivation", "(", derivationEval, 4);

    system("install", "derivation", "diff", difformLieDer, 2);

    // Libraries needed
    LIB "ring.lib";

}


////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
//                       Procedures concerning the differential algebra                       //
////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////
//---------------------------------- Construction procedures ---------------------------------//
////////////////////////////////////////////////////////////////////////////////////////////////


proc diffAlgebra()
"USAGE:         diffAlgebra();
SIDE EFFECTS:   If R is the basering, the differential algebra is constructed with name Omega_R
                and the differential forms dx_1,...,dx_n are available. The name of the differential
                algebra is stored in the attribute attrib(R,"diffAlgebra").
NOTE:           - computations with differential forms need the structure of the differential algebra,
                so this procedure should be executed first
                - the variable names 'd' or 'D' should be avoided
                - the procedure also works for quotient rings
                - the procedure checks if the differential algebra was already constructed - in this
                case, it is not constructed again
                - if the procedure is called from the TOP-level, a small information is printed
                - if the procedure is called from other procedures, the information text is avoided
KEYWORDS:       differential algebra; differential forms; differentials
SEE ALSO:       diffAlgebraStructure, diffAlgebraGens, diffAlgebraUnivDerIdeal
EXAMPLE:        example diffAlgebra; shows an example"
{

    // If qringNF is set, it is turned off: the option cannot manage the ring change performed here
    if(optionIsSet("qringNF")){
        option(noqringNF);
        print("// qringNF option was disabled - the option causes problems when changing to the differential algebra."); 
        print("// To reduce differential forms in case that the differential algebra has non-trivial relations,");
        print("// please use the procedure 'difformReduce'" + newline);
    }

    // Check if the differential algebra already exists
    // Throw warning if procedure is called from TOP-level
    if(diffAlgebraCheck("noError")){
        if(voice <= 2){
            print("// The differential algebra was already constructed.");
        }
        return();
    }
    
    // Build the differential algebra and store its name as an attribute
    string diffAlg_name = diffAlgebraStructure();
    attrib(basering,"diffAlgebra",diffAlg_name);

    // Construct the differential forms dx_1,...,dx_n over the basering
    diffAlgebraGens();

    // Info for User if procedure is called from TOP-level
    if(voice <= 2){
        list vars_ = ringlist(basering)[2];
        int n = size(vars_);
        int i;
        string difvar_forms;
        
        difvar_forms = "d" + vars_[1];
        for(i = 2; i <= n; i++){
            difvar_forms = difvar_forms + ", d" + vars_[i];
        }
        
        string info_text = "// The differential algebra " + attrib(basering,"diffAlgebra") + " was constructed and the differential forms " + difvar_forms + " are available.";
        print(info_text);
    }
}
example
{
"EXAMPLE:"; echo = 2;
///////////////////////////////////////////////////////////////
// Example for a differential algebra over a polynomial ring //
///////////////////////////////////////////////////////////////

ring R = 0,(a,b,c),ds;
diffAlgebra();
setring Omega_R;

// The differential algebra is given by:
basering;

kill R,Omega_R,da,db,dc;

/////////////////////////////////////////////////////////////
// Example for a differential algebra over a quotient ring //
/////////////////////////////////////////////////////////////

ring R = 0,(x,y,z),lp;
ideal I = x+y+z,xyz;
qring S = std(I);
diffAlgebra();
setring Omega_S;

// The differential algebra is given by:
basering;

kill Omega_S,dx,dy,dz;
}


////////////////////////////////////////////////////////////////////////////////////////////////


static proc diffAlgebraStructure()
"USAGE:     diffAlgebraStructure();
RETURN:     the structure of the differential algebra
REMARKS:    The differential algebra is constructed as non-commutative ring with
            additional variables Dx_1,...,Dx_n and 'exterior' relations between them.
            In the case, that the basering is a quotient ring, the defining ideal and its image
            under the universal derivation are added as relations.
NOTE:       - the monomial ordering of the basering is preserved in the differential algebra
            - the ordering for the variables Dx_1,...,Dx_n is always dp
KEYWORDS:   differential algebra
SEE ALSO:   diffAlgebra, diffAlgebraGens, diffAlgebraUnivDerIdeal"
{

    string basering_name = nameof(basering);
	list base_list = ringlist(basering);
    def R_old = basering;
    ideal quot_ideal = base_list[4];
	
	// Add Dx_1,...,Dx_n as first variables
	list ext_var = base_list[2];
	int n = size(ext_var);
	int i;

	for(i = 1; i <= n; i++){
        ext_var[n+i] = ext_var[i];
		ext_var[i] = "D" + ext_var[n+i];
	}

	base_list[2] = ext_var;

    // Preserve the monomial order of the basering
    // Add a new first block for the variables dx_i with dp ordering
    intvec weight_vec = 1:n;
    base_list[3] = list(list("dp",weight_vec)) + base_list[3];

	// Add relations x_i*x_j = x_j*x_i and dx_i*dx_j = -dx_j*dx_i
	int k = 2*n;
	matrix C[k][k];
	matrix D[k][k];
	int j;

	// Generate strictly upper triangular matrix describing the relations
	for(i = 1; i <= k; i++){
	    for(j = i+1; j <= k ; j++){
            if(j <= n){
		        C[i,j] = -1;
            }else{
                C[i,j] = 1;
            }
		}
	}

    base_list[4] = ideal(0);
	base_list[5] = C;
	base_list[6] = D;

	// Pass to non-commutative ring with extra variables and relations
	ring R_intermediate = ring(base_list);
	
	// Add relations Dx_i*Dx_i = 0 via generating a quotient ring
	ideal REL;
	for(i = 1; i <= n; i++){
		REL[i] = var(i)*var(i);
	}

	// Build the differential algebra for the polynomial ring - the free module
    qring diffAlg_poly = twostd(REL);

    // Need the relations describing the differential algebra if R is a quotient ring
    ideal quot_ideal = imap(R_old,quot_ideal);

    if(quot_ideal != 0){
        
        // Compute the universal derivation of the generators of the ideal
        quot_ideal = quot_ideal + diffAlgebraUnivDerIdeal(quot_ideal);

        // Add the additional relations, generate the differential algebra with name Omega_R and export it
        string diffAlg_name = "Omega_" + basering_name;
	    execute("qring " + diffAlg_name + " = twostd(quot_ideal);");
        execute("exportto(Top," + diffAlg_name + ");");

        return(diffAlg_name);
    }
    
    // Give the differential algebra the name Omega_basering and export it
    string diffAlg_name = "Omega_" + basering_name;
	execute("ring " + diffAlg_name + " = diffAlg_poly;");
    execute("exportto(Top," + diffAlg_name + ");");

    return(diffAlg_name);

}


////////////////////////////////////////////////////////////////////////////////////////////////


static proc diffAlgebraGens()
"USAGE:         diffAlgebraGens();
SIDE EFFECTS:   The differential forms dx_1,...,dx_n are constructed as objects
                of type 'difvar'.
REMARKS:        The procedure checks if dx_i needs to be constructed and prevents
                a redefining in case, dx_i was already constructed.
KEYWORDS:       differential algebra; generator
SEE ALSO:       diffAlgebra, diffAlgebraStructure, diffAlgebraUnivDerIdeal"
{

    diffAlgebraSwitch();

    list dvars = ringlist(basering)[2];
    int n = size(dvars) div 2;
    int i;
    int check_flag;
    string difvar_exist;
    string difvar_construct;

    for(i = 1; i <= n; i++){
        // Only construct those difvars which where not constructed yet - no redefining
        difvar_exist = "if(defined(d" + dvars[i+n] + ") == 1){ check_flag = 1; }else{ check_flag = 0; }";
        execute(difvar_exist);
        
        if(check_flag == 0){
            // Construct new difvar
            difvar_construct = "difvar d" + dvars[i+n] + ";";           
            difvar_construct = difvar_construct + "d" + dvars[i+n] + ".dvar = string(" + dvars[i] + ");";
            difvar_construct = difvar_construct + " exportto(Top," + "d" + dvars[i+n] + ")" + ";";
            execute(difvar_construct);
        }
    }
}


////////////////////////////////////////////////////////////////////////////////////////////////


static proc diffAlgebraUnivDerIdeal(ideal I)
"USAGE:     diffAlgebraUnivDerIdeal(I); I ideal
ASSUME:     current basering is the differential algebra of a polynomial ring
            and I is lifted from the polynomial ring
RETURN:     the image of I under the universal derivation
REMARKS:    The procedure computes the universal derivation of every generator of the ideal.
NOTE:       for differential forms, use the procedure difformUnivDer or difformDiff
KEYWORDS:   differential algebra; universal derivation
SEE ALSO:   diffAlgebra, diffAlgebraStructure, diffAlgebraGens"
{

    int n = size(ringlist(basering)[2]) div 2;
    int k = size(I);
    int i,j;
    ideal d_I;

    for(j = 1; j <= k; j++){
        d_I[j] = 0;
        for(i = 1; i <= n; i++){
            d_I[j] = d_I[j] + diff(I[j],var(i+n))*var(i);
        }
    }

    return(d_I);

}


////////////////////////////////////////////////////////////////////////////////////////////////
//----------------------------------- Structural procedures ----------------------------------//
////////////////////////////////////////////////////////////////////////////////////////////////


static proc diffAlgebraCheck(list #)
"USAGE:         diffAlgebraCheck();
SIDE EFFECTS:   Checks if the basering has a differential algebra and aborts with an
                error if this is not the case.
REMARKS:        The procedure checks if the name in the attribute attrib(basering,"diffAlgebra")
                has been set. This is the case if the procedure diffAlgebra was executed before.
NOTE:           - whenever computations with differential forms are done, it should be
                checked if the differential algebra was already generated
                - the option "noError" avoids throwing an error and just gives the result:
                    0 - if the differential algebra was not constructed yet
                    1 - if it was constructed
                - an optional ring can be given, then the procedure checks if the differential
                algebra exists over the given ring
KEYWORDS:       differential algebra; check
SEE ALSO:       diffAlgebraSwitch"
{
    
    int n = size(#);
    int i;
    int error_flag = 1;
    def save_ring = basering;

    // Check input
    for(i = 1; i <= n; i++){
        if(typeof(#[i]) == "string"){
            if(#[i] == "noError"){
                error_flag = 0;
            }
        }

        if(typeof(#[i]) == "ring"){
            save_ring = #[i];
        }
    }

    // Name of differential algebra is stored in attribute
    string attribute_name = attrib(save_ring,"diffAlgebra");

    // No error is thrown    
    if(error_flag == 0){
        if(!find(attribute_name,"Omega_")){
            return(0);
        }else{
            return(1);
        }
    }
    
    // Error is thrown
    if(!find(attribute_name,"Omega_")){
        ERROR("Ring does not have a differential algebra!");
    } 
}


////////////////////////////////////////////////////////////////////////////////////////////////


static proc diffAlgebraSwitch(list #)
"USAGE:         diffAlgebraSwitch();
ASSUME:         The differential algebra was already constructed.
SIDE EFFECTS:   Changes the ring: from the basering to the differential algebra.
NOTE:           - whenever computations with differential forms are done, the ring must 
                be changed to the differential algebra. But first it should be checked
                if the algebra is actually available: so before executing diffAlgebraSwitch 
                there should always be a preceding diffAlgebraCheck
                - an optional ring can be given, then the procedure changes to the differential
                algebra over the given ring
KEYWORDS:       differential algebra
SEE ALSO:       diffAlgebraCheck"
{
    
    int n = size(#);
    int i;
    def save_ring = basering;

    // Check input
    for(i = 1; i <= n; i++){
        if(typeof(#[i]) == "ring"){
            save_ring = #[i];
        }
    }

    // Change to differential algebra
    string diffAlg_name = attrib(save_ring,"diffAlgebra");
    execute("setring " + diffAlg_name + ";");
    execute("keepring " + diffAlg_name + ";");

}


////////////////////////////////////////////////////////////////////////////////////////////////


static proc diffAlgebraChangeOrd(list #)
"USAGE:     diffAlgebraChangeOrd(#); # list
ASSUME:     the current basering is the differential algebra
RETURN:     the differential algebra with changed monomial ordering
NOTE:       - an ordering is defined via the following pattern:
                - #[i] = 'gen' defines the ordering on the generators dx_i
                    - #[i+1] must then be a valid monomial ordering as string
                    - #[i+2] an optional weight vector
                - #[i] = 'ringvar' defines the ordering on the ringvariables
                    - #[i+1] must then be a valid monomial ordering as string
                    - #[i+2] an optional weight vector
            - only use for interior computations
            - differential forms are polynomials in the differential algebra - not in the returned ring
            - do not define differential forms as polynomials in the returned ring since this is another data-ring
            - an error occurs if:   - no valid monomial ordering is given
                                    - no weight vector is given but a weighted monomial ordering
                                    - a given weight vector has wrong dimension
            - weight vectors are ignored if the given ordering is not weighted
KEYWORDS:   ordering
SEE ALSO:   difformListSort, difformIsBigger, difformIsSmaller"
{

    int n = size(#);
    int k = size(ringlist(basering)[2]) div 2;
    int i;
    string gen_ord = "";
    string ringvar_ord = "";

    // Get information from input
    for(i = 1; i <= n; i++){
        if(typeof(#[i]) == "string"){

            if(#[i] == "gen" && typeof(#[i+1]) == "string"){
                gen_ord = #[i+1];
                if(typeof(#[i+2]) == "intvec"){
                    intvec gen_weight = #[i+2];
                }
            }

            if(#[i] == "ringvar" && typeof(#[i+1]) == "string"){
                ringvar_ord = #[i+1];
                if(typeof(#[i+2]) == "intvec"){
                    intvec ringvar_weight = #[i+2];
                }
            }
        }
    }

    // Check input for consistency
    // Generator ordering must be a valid monomial ordering
    if(gen_ord != "" && gen_ord != "lp" && gen_ord != "rp" && gen_ord != "dp" && gen_ord != "Dp" && gen_ord != "wp" && gen_ord != "Wp"){
        if(gen_ord != "ls" && gen_ord != "ds" && gen_ord != "Ds" && gen_ord != "ws" && gen_ord != "Ws"){
            ERROR("Not a valid ordering!");
        }
    }

    // Ringvariable ordering must be a valid monomial ordering
    if(ringvar_ord != "" && ringvar_ord != "lp" && ringvar_ord != "rp" && ringvar_ord != "dp" && ringvar_ord != "Dp" && ringvar_ord != "wp" && ringvar_ord != "Wp"){
        if(ringvar_ord != "ls" && ringvar_ord != "ds" && ringvar_ord != "Ds" && ringvar_ord != "ws" && ringvar_ord != "Ws"){
            ERROR("Not a valid ordering!");
        }
    }

    // If the generator ordering is a weighted monomial ordering, a weight-vector is needed
    if(gen_ord == "wp" || gen_ord == "Wp" || gen_ord == "ws" || gen_ord == "Ws"){
        if(defined(gen_weight) < 2){
            ERROR("No weight vector given!");
        }

        if(size(gen_weight) != k){
            ERROR("Weight vector has wrong size!");
        }
    }else{
    // If a weight vector is given although the monomial ordering is not weighted
        if(defined(gen_weight) >= 2){
            kill gen_weight;
        }
    }

    // If the ordering for the ring variables is a weighted monmial ordering, a weight-vector is needed
    if(ringvar_ord == "wp" || ringvar_ord == "Wp" || ringvar_ord == "ws" || ringvar_ord == "Ws"){
        if(defined(ringvar_weight) < 2){
            ERROR("No weight vector given!");
        }

        if(size(ringvar_weight) != k){
            ERROR("Weight vector has wrong size!");
        }
    }else{
    // If a weight vector is given although the monomial ordering is not weighted
        if(defined(ringvar_weight) >= 2){
            kill ringvar_weight;
        }
    }

    // Change the ordering to the given one
    list L_diff_Alg = ringlist(basering);
    n = size(L_diff_Alg[3]);
    
    // Change ordering of generators
    if(gen_ord != ""){
        L_diff_Alg[3][1][1] = gen_ord;
        if(defined(gen_weight) >= 2){
            L_diff_Alg[3][1][2] = gen_weight;
        }
    }

    // Change the ordering of the ringvariables
    if(ringvar_ord != ""){
        list L;
        L[1] = L_diff_Alg[3][1];
        
        L[2] = list();
        L[2][1] = ringvar_ord;
        if(defined(ringvar_weight) >= 2){
            L[2][2] = ringvar_weight;
        }else{
            L[2][2] = 1:k;
        }

        L_diff_Alg[3] = L;
    }

    def T = ring(L_diff_Alg);
    return(T);

}


////////////////////////////////////////////////////////////////////////////////////////////////


proc diffAlgebraRelations()
"USAGE:     diffAlgebraRelations();
RETURN:     the relations in the differential algebra over a quotient ring
NOTE:       - if the basering is not a quotient ring, the procedure returns the empty list
            - the terms dx_i^2 = 0 are part of the ring structure and are not seen as relations
KEYWORDS:   relations; quotient
SEE ALSO:   diffModuleRelations
EXAMPLE:    example diffAlgebraRelations; shows an example"
{

    diffAlgebraCheck();

    def R_old = basering;
    list REL;
    difform current_form;

    diffAlgebraSwitch();

    // Relation ideal of the differential algebra as list of differential forms
    ideal rel_ideal = ringlist(basering)[4];
    int n = size(rel_ideal);
    int i;

    for(i = 1; i <= n; i++){
        current_form.form = rel_ideal[i];
        REL[i] = current_form;
    }

    setring R_old;
    
    // Delete the relations dx_i^2
    n = size(ringlist(basering)[2]);
    int k = size(REL);

    // Delete the last n elements - these are the relations dx_i^2
    for(i = 0; i < n; i++){
        REL = delete(REL,k-i);
    }

    return(REL);

}
example
{
"EXAMPLE:"; echo = 2;

///////////////////////////////////
// Relations for a quotient ring //
///////////////////////////////////
ring S = 0,(x,y,z,a,b,c),dp;
ideal I = x2y2-z,z2+abc - 2x;
qring R = std(I);
diffAlgebra();

diffAlgebraRelations();
kill R,Omega_R,dx,dy,dz,da,db,dc;

/////////////////////////////////////
// Relations for a polynomial ring //
/////////////////////////////////////
ring R = 0,(a,b,c,t),(lp(2),dp(2));
diffAlgebra();

diffAlgebraRelations();
kill Omega_R,da,db,dc,dt;
}


////////////////////////////////////////////////////////////////////////////////////////////////
//------------------------- Procedures for computing with generators -------------------------//
////////////////////////////////////////////////////////////////////////////////////////////////


proc diffAlgebraListGens(list #)
"USAGE:     diffAlgebraListGens(#); # list
RETURN:     - a list of generetors of the differential algebra as module over the basering
            - a list of generators of a graded part of the differential algebra
REMARKS:    In order to find all generators, they are counted 'binary': The generators are in
            1:1 - correspondance to the dual number representations of 1 up to (2^n-1)
NOTE:       - if all generators of the differential algebra are needed, apply the 
            procedure without input
            - if the generator(s) of a graded part are needed, apply the procedure with 
            an integer which specifies the wanted degree
            - the list of generators is sorted with respect to the monomial ordering on the
            differential algebra
KEYWORDS:   generators; graded
SEE ALSO:   diffAlgebraIntToDual, diffAlgebraDualToGen, 
EXAMPLE:    example diffAlgebraListGens; shows an example"
{

    diffAlgebraCheck();
    
    int n = size(ringlist(basering)[2]);
    int i;
    int degr = -1;
    list GEN_list;
    difform current_gen;
    
    // Get optional degree
    if(size(#) > 0){
        if(typeof(#[1]) == "int"){
            degr = #[1];
        }
    }

    // Find all generators (of given degree)
    for(i = 1; i < 2^n; i++){
        
        // Compute the generator via dual number representation
        current_gen = diffAlgebraDualToGen(diffAlgebraIntToDual(i));
        
        // Add generator if it has the given degree or degree was not chosen
        if(degr == -1 || difformDeg(current_gen) == degr){
            GEN_list = GEN_list + list(current_gen);
        }
    }

    // Add generator 1
    if(degr == 0 || degr == -1){
        difform gen_one = 1;
        GEN_list = list(gen_one) + GEN_list;
    }

    return(difformListSort(GEN_list));

}
example
{
"EXAMPLE:"; echo = 2;
ring R = 11,(x,y,z),dp;
diffAlgebra();

////////////////////////////////////////////
// Generators of the differential algebra //
////////////////////////////////////////////
diffAlgebraListGens();

//////////////////////////////////////////
// Generators of the second graded part //
//////////////////////////////////////////
diffAlgebraListGens(2);

kill Omega_R,dx,dy,dz;
}


////////////////////////////////////////////////////////////////////////////////////////////////


static proc diffAlgebraListVar()
"USAGE:     diffAlgebraListVar();
ASSUME:     the differential algebra was already constructed
RETURN:     a list of basic differential forms dx_1,...,dx_n
KEYWORDS:   generators; list; variables"
{

    diffAlgebraSwitch();

    // Build the list of all dx_i
    list var_list;
    difform current_var;
    int n = size(ringlist(basering)[2]) div 2;
    int i;

    for(i = 1; i <= n; i++){
        current_var.form = var(i);
        var_list[i] = current_var;
    }

    return(var_list);

}


////////////////////////////////////////////////////////////////////////////////////////////////
//------------------------------ Type casts and conversions ----------------------------------//
////////////////////////////////////////////////////////////////////////////////////////////////


proc diffAlgebraIntToDual(int l)
"USAGE:     diffAlgebraIntToDual(l); l int
RETURN:     the dual number representation of l as a list
NOTE:       the LSBF (least significant bit first) representation is computed
KEYWORDS:   dual; int
SEE ALSO:   diffAlgebraListGens
EXAMPLE:    example diffAlgebraIntToDual; shows an example"
{

    // Check if the given number is negative
    if(l < 0){
        ERROR("Given number is negative!");
    }

    list dual_number;

    while(l div 2 != 0){
        dual_number = dual_number + list(l mod 2);
        l = l div 2;
    }

    dual_number = dual_number + list(l mod 2);

    return(dual_number);

}
example
{
"EXAMPLE:"; echo = 2;
////////////////////////////////////////
// Transform integers to dual numbers //
////////////////////////////////////////
diffAlgebraIntToDual(3);
diffAlgebraIntToDual(13);
diffAlgebraIntToDual(22);
}


////////////////////////////////////////////////////////////////////////////////////////////////


proc diffAlgebraGenToDual(difform df)
"USAGE:     diffAlgebraGenToDual(df); df difform
RETURN:     the given generator in dual number representation
REMARKS:    Generators and dual numbers from 1 up to (2^n-1) are in 1:1 - correspondance
KEYWORDS:   dual; generator
SEE ALSO:   diffAlgebraDualToGen
EXAMPLE:    example diffAlgebraGenToDual; shows an example"
{

    diffAlgebraCheck();

    // Check if given differential form is not a generator
    if(!difformIsGen(df)){
        ERROR("Given form is not a generator!");
    }

    list GEN_1_list = diffAlgebraListVar();
    list dual_i;
    int n = size(GEN_1_list);
    int i;
    
    for(i=1; i <= n; i++){
        // Test which dx_i are in the generator
        if(difformNeq(difformDiv(df,GEN_1_list[i]),0)){
            dual_i = dual_i + list(1);
        }else{
            dual_i = dual_i + list(0);
        }
    }
    
    return(dual_i);

}
example
{
"EXAMPLE:"; echo = 2;
ring R = 11,(x,y,t),lp;
diffAlgebra();

//////////////////////////////////////////
// Transform generators to dual numbers //
//////////////////////////////////////////
diffAlgebraGenToDual(1);
diffAlgebraGenToDual(dx);
diffAlgebraGenToDual(dx*dy*dt);
}


////////////////////////////////////////////////////////////////////////////////////////////////


proc diffAlgebraDualToGen(list dual_i)
"USAGE:     diffAlgebraDualToGen(dual_i); dual_i list
RETURN:     the generator corresponding to the given dual number
REMARKS:    Generators and dual numbers from 1 up to (2^n-1) are in 1:1 - correspondance
KEYWORDS:   dual; generator
SEE ALSO:   diffAlgebraGenToDual
EXAMPLE:    example diffAlgebraDualToGen; shows an example"
{

    diffAlgebraCheck();

    list GEN_1_list = diffAlgebraListVar();
    difform d_gen = 1;
    int k = size(dual_i);
    int j;

    // If the dual number is too big
    if(size(GEN_1_list) < k){
        ERROR("No generator for this dual number!");
    }
    
    // Check if given list represents a dual number
    // Convert dual number to generator
    for(j = 1; j <= k; j++){
        if(dual_i[j] == 0 || dual_i[j] == 1){
            if(dual_i[j] == 1){
                d_gen = d_gen*GEN_1_list[j];
            }
        }else{
            ERROR("List does not represent a dual number!");
        }
    }
    
    return(d_gen);
    
}
example
{
"EXAMPLE:"; echo = 2;
ring R = 0,(x,y,z),ls;
diffAlgebra();

//////////////////////////////////////////
// Transform dual numbers to generators //
//////////////////////////////////////////
diffAlgebraDualToGen(list(0,0));
diffAlgebraDualToGen(list(1,0,1));
diffAlgebraDualToGen(list(1,0));
}


////////////////////////////////////////////////////////////////////////////////////////////////


proc diffAlgebraDualToIntvec(list dual_i)
"USAGE:     diffAlgebraDualToIntvec(dual_i); dual_i list
RETURN:     an intvec with same entries as the dual number representation
KEYWORDS:   dual; intvec
SEE ALSO:   diffAlgebraIntvecToDual
EXAMPLE:    example diffAlgebraDualToIntvec; shows an example"
{

    intvec v;
    int n = size(dual_i);
    int i;

    // Check if the list is a dual-number representation
    // Store this representation in an intvec
    for(i = 1; i <= n; i++){
        if(dual_i[i] == 0 || dual_i[i] == 1){
            v[i] = dual_i[i];
        }else{
            ERROR("List does not represent a dual number!");
        }
    }
    
    return(v);

}
example
{
"EXAMPLE:"; echo = 2;

///////////////////////////////////////
// Transform dual numbers to intvecs //
///////////////////////////////////////
diffAlgebraDualToIntvec(list(1,0,1));
diffAlgebraDualToIntvec(list(0,0));
diffAlgebraDualToIntvec(list(1));
}


////////////////////////////////////////////////////////////////////////////////////////////////


proc diffAlgebraIntvecToDual(intvec v)
"USAGE:     diffAlgebraIntvecToDual(dual_i); dual_i list
RETURN:     a dual number representation-list with same entries as the given intvec
KEYWORDS:   dual; intvec
SEE ALSO:   diffAlgebraDualToIntvec
EXAMPLE:    example diffAlgebraIntvecToDual; shows an example"
{

    int n = size(v);
    int i;
    list dual_i;

    // Check if the intvec is a dual-number representation
    // Store this representation in a list
    for(i = 1; i <= n; i++){
        if(v[i] == 0 || v[i] == 1){
            dual_i[i] = v[i];
        }else{
            ERROR("Vector does not represent a dual number!");
        }
    }

    return(dual_i);

}
example
{
"EXAMPLE:"; echo = 2;

///////////////////////////////////////
// Transform intvecs to dual numbers //
///////////////////////////////////////
diffAlgebraIntvecToDual(1:3);
diffAlgebraIntvecToDual(intvec(0,0,1));
diffAlgebraIntvecToDual(intvec(1));
}


////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
//                                Procedures for type difform                                 //
////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////
//-------------------------------- Type casts and constructor --------------------------------//
////////////////////////////////////////////////////////////////////////////////////////////////


static proc difformFromDifvar(difvar d_var)
"USAGE:     difformFromDifvar(d_var); d_var difvar
RETURN:     the differential form defined by d_var
REMARKS:    d_var represents a variable of the differential algebra. The
            resulting differential form is this variable.
KEYWORDS:   constructor; differential form; variable
SEE ALSO:   difformFromType"
{
    
    diffAlgebraCheck();
    diffAlgebraSwitch();
    
    difform df;
    string poly_construct = "poly g = " + d_var.dvar;
    execute(poly_construct);
    df.form = g;

    return(df);
    
}


////////////////////////////////////////////////////////////////////////////////////////////////


static proc difformFromPoly(poly f)
"USAGE:     difformFromPoly(f); f poly
RETURN:     the differential form of degree 0 defined by f
REMARKS:    The given polynomial gets lifted to the differential algebra 
            and the differential form is defined there.
KEYWORDS:   constructor; differential form; polynomial
SEE ALSO:   difformFromType"
{

    diffAlgebraCheck();
    def R_old = basering;
    diffAlgebraSwitch();

    poly g = imap(R_old,f);
    difform df;
    df.form = g;

    return(df);

}


////////////////////////////////////////////////////////////////////////////////////////////////


proc difformFromType(def t_in)
"USAGE:     difform df = t_in; t_in of any type
RETURN:     the differential form defined by t_in
NOTE:       the types difvar, poly, int, bigint, number and vector 
            define differential forms
KEYWORDS:   constructor; differential form
SEE ALSO:   difformFromDifvar, difformFromPoly, difformFromVector
EXAMPLE:    example difformFromType; shows an example"
{
    
    difform df;
    string NL = newline + tab(5);
    
    while(1){
        // Allowed types
        if(typeof(t_in) == "difvar"){ df = difformFromDifvar(t_in); break; }
        if(typeof(t_in) == "poly"){ df = difformFromPoly(t_in); break; }
        if(typeof(t_in) == "int"){ df = difformFromPoly(t_in); break; }
        if(typeof(t_in) == "bigint"){ df = difformFromPoly(t_in); break; }
        if(typeof(t_in) == "number"){ df = difformFromPoly(t_in); break; }
        if(typeof(t_in) == "vector"){ df = difformFromVector(t_in); break; }

        // Wrong type
        ERROR("Wrong type - expected type:" + NL + "difvar" + NL + "poly" + NL + "int" + NL + "bigint" + NL + "number" + NL + "vector");
    }
    
    return(df);
}
example
{
"EXAMPLE:"; echo = 2;
ring R = 0,(x,y,z),ds;
diffAlgebra();

////////////////////////////////////////
// Construction of differential forms //
////////////////////////////////////////

difform dh = 1; dh;
difform di = dx; dx;

poly f = 3x3z*(y4-y5) + 2;
difform df = f; df;

// For the construction of more general differential forms,
// the constructor is used implicitly:

difform da = x*gen(3) - 12*gen(1) + 13*(y4-z5)*gen(8); da;

difform dg = 3*x*dx - y*dy + dx*dy*dz + 1; dg;

kill Omega_R,df,dg,dh,di,da,dx,dy,dz;
}


////////////////////////////////////////////////////////////////////////////////////////////////


static proc difformGenToString(difform df)
"USAGE:     difformGenToString(df); df difform
RETURN:     the differential form df as a string - but with unsorted coefficients
NOTE:       - this is only used to print generators
            - the procedure replaces the 'D' from the variables of the differential algebra
            by an 'd'
KEYWORDS:   string; print; generators
SEE ALSO:   difformToString"
{
    
    diffAlgebraSwitch();
    string df_out = string(df.form);
    list vars_ = ringlist(basering)[2];
    int n = size(vars_) div 2;
    int i,j;
    
    // Replace the Dx_i in the string with the dx_i
    for(i = 1; i <= n; i++){
        j = find(df_out,string(vars_[i]));

        while(j!=0){
            df_out[j] = "d";
            j = find(df_out,vars_[i]);
        }
    }
    
    return(df_out);
    
}


////////////////////////////////////////////////////////////////////////////////////////////////


proc difformToString(difform df, list #)
"USAGE:     difformToString(df,#); df difform, # list
RETURN:     df as a string, sorted by a given ordering on the generators 
            (standard odering is the ordering of the differential algebra)
REMARKS:    The differential form is decomposed via difformCoef, the coefficient list is sorted 
            and then the string is built as concatenation of coefficients and generators
NOTE:       to get a string, respecting a certain monomial ordering on the generators, use:
                - #[1] = 'gen'
                - #[2]: a monomial ordering as string
                - #[3]: an optional weight vector
KEYWORDS:   string; print
SEE ALSO:   difformPrint, difformGenToString
EXAMPLE:    example difformToString; shows an example"
{

    // Get the coefficients
    list repr = difformCoef(df);
    
    // Get the optional ordering on the generators
    string gen_ord = "";
    int n = size(#);
    int i;
    
    for(i = 1; i <= n; i++){
        if(typeof(#[i]) == "string"){
            if(#[i] == "gen" && typeof(#[i+1]) == "string"){
                gen_ord = #[i+1];
                if(typeof(#[i+2]) == "intvec"){
                    intvec gen_weight = #[i+2];
                }
            }
        }
    }
    
    // Sort the generator/coefficients by the chosen ordering
    if(gen_ord != ""){
        if(defined(gen_weight) >= 2){
            repr = difformListSort(repr,"Llist","gen",gen_ord,gen_weight);
        }else{
            repr = difformListSort(repr,"Llist","gen",gen_ord);
        }
    }else{
        repr = difformListSort(repr,"Llist");
    }
    
    // Build the string
    n = size(repr);
    string df_out;
    
    difform df_gen;
    string df_gen_str;
    poly df_coef;
    string df_coef_str;

    for(i = n; i >= 1; i--){
        df_gen = repr[i][1];
        df_gen_str = difformGenToString(df_gen);
        df_coef = repr[i][2];
        df_coef_str = string(df_coef);
        
        // Check the coefficients and generators
        while(1){
            // Special cases without brackets:

            // Generator one - no sign
            if(df_gen_str == "1" && df_coef_str[1] != "-"){df_out = df_out + df_coef_str; break;}

            // Generator one - first part of string
            if(df_gen_str == "1" && size(df_out) == 0){df_out = df_coef_str; break;}

            // Generator not one - coefficient is one
            if(df_gen_str != "1" && df_coef == 1){df_out = df_out + df_gen_str; break;}
            
            // Generator not one - coefficient not one - coefficient has one term - term has no sign
            if(df_gen_str != "1" && df_coef != 1 && size(df_coef) == 1 && df_coef_str[1] != "-"){df_out = df_out +  df_coef_str + "*" + df_gen_str; break;}

            // Case, where brackets are needed:

            // Generator one - term has sign - not first part
            if(df_gen_str == "1" && df_coef_str[1] == "-" && size(df_out) != 0){df_out = df_out + "(" + df_coef_str + ")"; break;}

            // Otherwise
            df_out = df_out + "(" + df_coef_str + ")*" + df_gen_str; break;
        }

        // Add a plus sign
        if(i > 1){
            df_out = df_out + "+";
        }
    }

	return(df_out);

}
example
{
"EXAMPLE:"; echo = 2;
ring R = 0,(x,y,z,a,b),ds;
diffAlgebra();

difform df = 3*x*dx -2*db + 24*a*dy - y*dx*dy*db + 12*dx*dy*dz - dz*dy*da*db + 3 + 12*x*dx - 1/77*da*dx;

//////////////////////////////////////////////////////////////////////////////////
// String sorted with respect to the monomial order on the differential algebra //
//////////////////////////////////////////////////////////////////////////////////
string df_str = difformToString(df);
print(df_str);

/////////////////////////////////////////////////////////
// String sorted with respect to the weighted order wp //
/////////////////////////////////////////////////////////
df_str = difformToString(df,"gen","wp",intvec(-1,-1,-1,1,1));
print(df_str);

kill Omega_R,df,df_str,dx,dy,dz,da,db;
}


////////////////////////////////////////////////////////////////////////////////////////////////


static proc difformGenToVector(difform df, list GEN_list)
"USAGE:     difformGenToVector(df,GEN_list); df difform, GEN_list list
ASSUME:     - df is a generator of the differential algebra
            - GEN_list is the sorted list of generators of 
            the differential algebra
RETURN:     the standard basis vector corresponding to the given generator
REMARKS:    The ordering of the generators determines the assignment: 
            generator <-> basis vector
KEYWORDS:   vector; generator
SEE ALSO:   difformToVector, difformFromVector, difformGenFromVector"
{

    vector v = gen(difformListContains(GEN_list,df,"index"));
    return(v);

}


////////////////////////////////////////////////////////////////////////////////////////////////


proc difformToVector(difform df, list #)
"USAGE:     difformToVector(df); df difform
RETURN:     the vector corresponding to the given differential form
REMARKS:    - This models an isomorphism between the differential algebra,
            as abstract module over the basering, and a free/quotient module.
            - The generators are translated to basis vectors and the 
            coefficients are multiplied with those.
NOTE:       the option is only for interior use
KEYWORDS:   vector; differential form
SEE ALSO:   difformGenToVector, difformFromVector, difformGenFromVector
EXAMPLE:    example difformToVector; shows an example"
{

    diffAlgebraCheck();

    if(size(#) > 0){
        list GEN_list = #;
    }else{
        list GEN_list = diffAlgebraListGens();
    }

    list df_coef = difformCoef(df);
    int n = size(df_coef);
    int i;
    vector df_vec = 0;
    
    for(i = 1; i <= n; i++){
        df_vec = df_vec + df_coef[i][2]*difformGenToVector(df_coef[i][1],GEN_list);
    }

    return(df_vec);

}
example
{
"EXAMPLE:"; echo = 2;
ring R = 13,(x,y,z),lp;
diffAlgebra();

/////////////////////////////////////////////////////////
// The generators correspond to standard basis vectors //
/////////////////////////////////////////////////////////

difformToVector(1);
difformToVector(dz);
difformToVector(dy);
difformToVector(dx);
difformToVector(dx*dy*dz);

////////////////////////////////
// General differential forms //
////////////////////////////////

print(difformToVector(12*x*dx + y4*dy*dx - dx*dz*dy + 3*dz));

kill Omega_R,dx,dy,dz;
}


////////////////////////////////////////////////////////////////////////////////////////////////


proc difformFromVector(vector v, list #)
"USAGE:     difformFromVector(v); v vector
RETURN:     the differential form corresponding to the given vector
REMARKS:    - This models an isomorphism between a free/quotient module and
            the differential algebra, as abstract module over the basering.
            - The basis vectors are casted to generators and the vector
            entries are multiplied with those.
NOTE:       the option is only for interior use
KEYWORDS:   vector; differential form
SEE ALSO:   difformGenFromVector, difformToVector, difformGenToVector, difformFromType
EXAMPLE:    example difformFromVector; shows an example"
{

    diffAlgebraCheck();

    if(size(#) > 0){
        list GEN_list = #;
    }else{
        list GEN_list = diffAlgebraListGens();
    }

    int n = size(GEN_list);
    int i;
    difform df;
    
    for(i = 1; i <= n; i++){
        df = df + v[i]*GEN_list[i];
    }

    return(df);

}
example
{
"EXAMPLE:"; echo = 2;
ring R = 13,(x,y,z),lp;
diffAlgebra();

/////////////////////////////////////////////////////////
// The standard basis vectors correspond to generators //
/////////////////////////////////////////////////////////

difformFromVector(gen(1));
difformFromVector(gen(4));
difformFromVector(gen(8));

////////////////////////////////
// General differential forms //
////////////////////////////////

difformFromVector(y2*gen(1) - (x2+z4)*gen(7) + gen(4) - z2y2*gen(3));

kill Omega_R,dx,dy,dz;
}


////////////////////////////////////////////////////////////////////////////////////////////////
//----------------------------------- Structural procedures ----------------------------------//
////////////////////////////////////////////////////////////////////////////////////////////////


proc difformCoef(difform df)
"USAGE:     difformCoef(df); df difform
RETURN:     list of lists of differential forms and polynomials: 
            - the first entry is a generator of the differential algebra which appears in df
            - the second entry is the corresponding coefficient
REMARKS:    Via the procedure coef, the coefficients are found - therefore the ring has to be changed to the
            differential algebra. After that, the coefficients have to be mapped back to the original ring.
NOTE:       the returned list can be sorted with the procedure difformListSort and the optional string 'Llist'
KEYWORDS:   decomposition; generators; coefficients
EXAMPLE:    example difformCoef; shows an example"
{
    
    diffAlgebraCheck();
    
    def R_old = basering;
    diffAlgebraSwitch();
    def diff_Alg = basering;

    poly f = df.form;
    int n = size(ringlist(basering)[2]) div 2;
    int i;
    
	// Build the wedge product of all differential forms dx_i
	poly wedge_mon = 1;
	for(i = 1; i <= n; i++){
		wedge_mon = wedge_mon*var(i);
	}

	// Find the coefficients of the generators
    matrix df_coefs = coef(f,wedge_mon);
    int k = ncols(df_coefs);
    
    // Store representation in a list
    poly coeff_above;
    setring R_old;
    difform current_gen;
    poly coeff;
    list repr;
    
    for(i = 1;i <= k;i++){
        repr[i] = list();
        setring diff_Alg;
        
        // Generators as differential forms
        current_gen.form = df_coefs[1,i];
        
        // Coefficients are polynomials in the basering
        coeff_above = df_coefs[2,i];
        setring R_old;
        coeff = imap(diff_Alg,coeff_above);
        
        // Store everything in the representation
        repr[i][1] = current_gen;
        repr[i][2] = coeff;
    }
    
    // Return representation
    return(repr);

} 
example
{
"EXAMPLE:"; echo = 2;
ring R = 0,(x,y,z),lp;
diffAlgebra();

difform df = 3*x25*dx - y*dx*dy + 12*dx*dy*dz - dz*dy + 3 + 12*x*dx + 24*(y4-y5) + dx*dy*x3*dz + dz - dy*dx + dz*x2 + z5*y*dy;

///////////////////////////////
// Unsorted Coefficient List //
///////////////////////////////
list L_1 = difformCoef(df);
L_1;

/////////////////////////////
// Sorted Coefficient List //
/////////////////////////////
L_1 = difformListSort(L_1,"Llist","gen","ds"); 
L_1;

kill Omega_R,df,dx,dy,dz,L_1;
}


////////////////////////////////////////////////////////////////////////////////////////////////


proc difformCoefIntvec(difform df)
"USAGE:     difformCoefIntvec(df); df difform
RETURN:     list of lists of intvecs and polynomials: 
            - the first entry is an intvec, representing a generator which appears in df
            - the second entry is the corresponding coefficient
REMARKS:    difformCoef is used to compute the generator/coefficient representation and then
            the generators are translated to intvecs
KEYWORDS:   decomposition; generators; coefficients; intvec
SEE ALSO:   difformCoef, diffAlgebraGenToDual, diffAlgebraDualToIntvec
EXAMPLE:    example difformCoefIntvec; shows an example"
{
    
    // The coefficients
    list df_coef = difformListSort(difformCoef(df),"Llist","gen","ds");

    // The generators are transformed to intvecs
    list df_coef_intvec;
    int n = size(df_coef);
    int i;
    for(i = 1; i <= n; i++){
        df_coef_intvec[i] = list();
        df_coef_intvec[i][1] = diffAlgebraDualToIntvec(diffAlgebraGenToDual(df_coef[n-i+1][1]));
        df_coef_intvec[i][2] = df_coef[n-i+1][2];
    }

    return(df_coef_intvec);

}
example
{
"EXAMPLE:"; echo = 2;
ring R = 0,(x,y,z,t),(dp(2),lp);
diffAlgebra();

difform df = 3*dx - 1/3*y4*dy + (x2-y3)*dx*dy*dz - t*dt + dy*dz + 2*dt*dx - dx*dt;

///////////////////////////////////
// Coefficient List with intvecs //
///////////////////////////////////
difformCoefIntvec(df);

kill Omega_R,df,dx,dy,dz,dt;
}


////////////////////////////////////////////////////////////////////////////////////////////////


proc difformPrint(difform df)
"USAGE:         df; df difform
SIDE EFFECTS:   Prints the differential form.
REMARKS:        Uses the procedure difformToString with a ds-ordering on the generators
KEYWORDS:       print; string
SEE ALSO:       difformToString, difformGenToString
EXAMPLE:        example difformPrint; shows an example"
{

    // Print in ds-order on the generators
	print(difformToString(df,"gen","ds"));

}
example
{
"EXAMPLE:"; echo = 2;
ring R = 0,(x,y,z),ds;
diffAlgebra();

//////////////////////////
// Application of Print //
//////////////////////////

difform df = 3*x*dx - y*dx*dy + 12*dx*dy*dz - dz*dy + 3 + 12*x*dx;
df;

kill Omega_R,df,dx,dy,dz;
}


////////////////////////////////////////////////////////////////////////////////////////////////


proc difformIsGen(difform df)
USAGE:      difformIsGen(df); df difform
RETURN:     1, if df is a generator of the differential algebra - 0, otherwise
REMARKS:    Uses the procedure difformCoef and tests for a single coefficient which is one
KEYWORDS:   generator
SEE ALSO:   difformCoef
EXAMPLE:    example difformIsGen; shows an example
{
    
    diffAlgebraCheck();
    
    list df_gen_repr = difformCoef(df);
    int n = size(df_gen_repr);
    
    if(n == 1 && df_gen_repr[1][2] == 1){
        return(1);
    }
    
    return(0);
    
}
example
{
"EXAMPLE:"; echo = 2;
ring R = 0,(x,y,z,a,b,c),lp;
diffAlgebra();

////////////////
// Generators //
////////////////
difformIsGen(1);
difformIsGen(dx);
difformIsGen(da*dc);
difformIsGen(dy*da*db);
difformIsGen(-da*dz);

///////////////////
// No generators //
///////////////////
difformIsGen(-1);
difformIsGen(-dx);
difformIsGen(dc*da);
difformIsGen(dy*db*da);
difformIsGen(dx*dz*dy);

kill Omega_R,dx,dy,dz,da,db,dc;
}


////////////////////////////////////////////////////////////////////////////////////////////////


proc difformImap(def target_ring, difform df)
"USAGE:     imap(target_ring,df); target_ring ring, df difform
RETURN:     a differential form: the image of df under imap in the
            differential algebra over the basering
REMARKS:    The procedure switches to the differential algebra over the 
            basering and applies imap there to the content of the 
            differential form.
NOTE:       - like imap, difformImap maps variables to variables with equivalent names
            - the given differential form has to be defined over the given ring
KEYWORDS:   imap
SEE ALSO:   difformFetch
EXAMPLE:    example difformImap; shows an example"
{

    diffAlgebraCheck();
    def save_ring = basering;
    
    // target_ring is a ring
    if(typeof(target_ring) != "ring"){
        ERROR("No valid ring given!");
    }

    // df must be defined over the target_ring
    difformDefined(target_ring,df);
    
    // This ring must have a differential algebra and the differential form
    // has its content in the differnetial algebra over the target ring
    diffAlgebraCheck(target_ring);
    diffAlgebraSwitch(target_ring);
    def target_algebra = basering;
    
    // Store form of df as polynomial
    poly f = df.form;

    // imap poly to the differential algebra over basering
    // and store mapped poly in a difform
    diffAlgebraSwitch(save_ring);
    poly f_form = imap(target_algebra,f);
    difform dg;
    dg.form = f_form;
    
    return(dg);

}
example
{
"EXAMPLE:"; echo = 2;
///////////////////////////////////////////
// Construction of differential algebras //
///////////////////////////////////////////
ring R = 0,(x,y,z),lp;
diffAlgebra();

///////////////////////////////////////////
ring S = 11,(a,b,x,y),dp;
diffAlgebra();
difform dg = 3x*dx + a*b - da + 2*y;

////////////////////////////////
// Map differential form to R //
////////////////////////////////
setring R;
difform dh = imap(S,dg); dh;

kill Omega_R,Omega_S,dx,dy,dz,da,db,dh,dg;
}


////////////////////////////////////////////////////////////////////////////////////////////////


proc difformFetch(def target_ring, difform df)
"USAGE:     difformFetch(target_ring,df); target_ring ring, df difform
RETURN:     a differential form: the image of df under fetch in the
            differential algebra over the basering
REMARKS:    The procedure switches to the differential algebra over the 
            basering and applies fetch there to the content of the 
            differential form.
NOTE:       - like fetch, difformFetch maps variables to variables with same positions
            - d-variables (dx_i) are mapped to d-variables, ringvariables are mapped to ringvariables
            - the given differential form has to be defined over the given ring
KEYWORDS:   fetch
SEE ALSO:   difformImap
EXAMPLE:    example difformFetch; shows an example"
{

    diffAlgebraCheck();
    def save_ring = basering;
    
    // target_ring is a ring
    if(typeof(target_ring) != "ring"){
        ERROR("No valid ring given!");
    }

    // df must be defined over the target_ring
    difformDefined(target_ring,df);
    
    // This ring must have a differential algebra and the differential form
    // has its content in the differnetial algebra over the target ring
    diffAlgebraCheck(target_ring);
    diffAlgebraSwitch(target_ring);
    def target_algebra = basering;
    
    // Store form of df as polynomial
    poly f = df.form;

    // Number of variables
    setring save_ring;
    int k = size(ringlist(basering)[2]);
    setring target_ring;
    int n = size(ringlist(basering)[2]);

    // Choose suitable intvec for fetch
    int i;
    intvec fetch_vec;
    if(n > k){
        for(i = 1; i <= k; i++){
            fetch_vec[i] = i;
            fetch_vec[n+i] = k+i;
        }
    }else{
        for(i = 1; i <= n; i++){
            fetch_vec[i] = i;
            fetch_vec[n+i] = k+i;
        }
    }
    
    // fetch poly to the differential algebra over basering
    // and store mapped poly in a difform
    diffAlgebraSwitch(save_ring);
    poly f_form = fetch(target_algebra,f,fetch_vec);
    difform dg;
    dg.form = f_form;
    
    return(dg);

}
example
{
"EXAMPLE:"; echo = 2;
///////////////////////////////////////////
// Construction of differential algebras //
///////////////////////////////////////////
ring R = 0,(x,y,z),lp;
diffAlgebra();

///////////////////////////////////////////
ring S = 11,(a,b,c,e,f),dp;
diffAlgebra();
difform dt = a*da + b*db + da*dc + e*df*da + a + e*f;

////////////////////////////////
// Map differential form to R //
////////////////////////////////
setring R;
difform dh = difformFetch(S,dt); dh;

kill Omega_R,Omega_S,dx,dy,dz,da,db,dc,de,df,dt,dh;
}


////////////////////////////////////////////////////////////////////////////////////////////////
//------------------------------ Basic computational procedures ------------------------------//
////////////////////////////////////////////////////////////////////////////////////////////////


proc difformAdd(difform df, difform dg)
"USAGE:     df+dg; df,dg difform
RETURN:     the sum of the differential forms as differential form
KEYWORDS:   add; sum
SEE ALSO:   difformSub
EXAMPLE:    example difformAdd; shows an example"
{

    diffAlgebraCheck();
    diffAlgebraSwitch();

    difform dsum;
    poly sum_form = df.form + dg.form;
    dsum.form = sum_form;

    return(dsum);

}
example
{
"EXAMPLE:"; echo = 2;
ring R = 0,(x,y,z),ds;
diffAlgebra();

////////////////////////////////////
// Addition of differential forms //
////////////////////////////////////

difform df = dx + 4*dy - dz*dx + 4 + 3*dx*dy + 4*dz;
difform dg = dx + dy + 27*dz*dy;
df+dg;

////////////////////////////////////////////////////
// Addition of polynomials and differential forms //
////////////////////////////////////////////////////

df + x2y2z2;
12 + dg;

kill Omega_R,df,dg,dx,dy,dz;
}


////////////////////////////////////////////////////////////////////////////////////////////////


proc difformSub(difform df, difform dg)
"USAGE:     df-dg; df,dg difform
RETURN:     the difference of the differential forms as differential form
KEYWORDS:   minus; difference
SEE ALSO:   difformAdd, difformNeg
EXAMPLE:    example difformSub; shows an example"
{

	diffAlgebraCheck();
    diffAlgebraSwitch();

    difform dsub;
    poly sub_form = df.form - dg.form;
    dsub.form = sub_form;

    return(dsub);

}
example
{
"EXAMPLE:"; echo = 2;
ring R = 0,(x,y,z),ds;
diffAlgebra();

///////////////////////////////////////
// Subtraction of differential forms //
///////////////////////////////////////

difform df = 5*dx*x2 - 7*dy*z - 2x2*dz - 3;
difform dg = dx - 8x*dz*dy;
df-dg;

///////////////////////////////////////////////////////
// Subtraction of polynomials and differential forms //
///////////////////////////////////////////////////////

df - 2x3;
1 - dg;

kill Omega_R,df,dg,dx,dy,dz;
}


////////////////////////////////////////////////////////////////////////////////////////////////


proc difformNeg(difform df)
"USAGE:     -df; df difform
RETURN:     the negation of the differential form
KEYWORDS:   minus; negation
SEE ALSO:   difformSub
EXAMPLE:    example difformNeg; shows an example"
{

	diffAlgebraCheck();
    diffAlgebraSwitch();

    difform dneg;
    poly neg_form = -df.form;
    dneg.form = neg_form;

    return(dneg);

}
example
{
"EXAMPLE:"; echo = 2;
ring R = 0,(x,y,z),ds;
diffAlgebra();

/////////////////////////////////////
// Negation of a differential form //
/////////////////////////////////////

difform df = 13*dx*dy + 2*dy*dz - 6*dx*dy*dz - 3;
-df;

kill Omega_R,df,dx,dy,dz;
}


////////////////////////////////////////////////////////////////////////////////////////////////


proc difformMul(difform df, difform dg)
"USAGE:     df*dg; df,dg difform
RETURN:     the product of the differential forms as differential form
KEYWORDS:   multiplication; product
SEE ALSO:   difformPow, difformDiv
EXAMPLE:    example difformMul; shows an example"
{

	diffAlgebraCheck();
    diffAlgebraSwitch();

    difform dmul;
    poly mul_form = df.form*dg.form;
    dmul.form = mul_form;

    return(dmul);

}
example
{
"EXAMPLE:"; echo = 2;
ring R = 0,(x,y,z),ds;
diffAlgebra();

//////////////////////////////////////////
// Multiplication of differential forms //
//////////////////////////////////////////

difform df = 13*dx*dy - 7*dy*dz - 6*dx*dy*dz;
difform dg = dx - 8x;
df*dg;

/////////////////////////////////////////////////////////
// Multiplication of polynomials and differential forms //
/////////////////////////////////////////////////////////

df*(y2-x);
12*dg;

kill Omega_R,df,dg,dx,dy,dz;
}


////////////////////////////////////////////////////////////////////////////////////////////////


proc difformPow(difform df, int n)
"USAGE:     df^n; df difform, n int
ASSUME:     n >= 0
RETURN:     the power of df by n
KEYWORDS:   multiplication; product; power
SEE ALSO:   difformMul
EXAMPLE:    example difformPow; shows an example"
{

   	diffAlgebraCheck();
    diffAlgebraSwitch();

    difform dpow;
    poly pow_form = (df.form)^n;
    dpow.form = pow_form;

    return(dpow);

}
example
{
"EXAMPLE:"; echo = 2;
ring R = 13,(x,y,z,a,b),dp;
diffAlgebra();

/////////////////////////////////
// Powers of differential form //
/////////////////////////////////

difform df = 13*dx*dy*db + 2*x*y*dy*da - a2*y*dy*dz + da*db -12*dx*dy*da*db + x2*y5;

df^0;
df^1;
df^2;
df^3;
df^13;

kill Omega_R,df,dx,dy,dz,da,db;
}


////////////////////////////////////////////////////////////////////////////////////////////////


proc difformDiv(difform df, difform dg)
"USAGE:     df/dg; df,dg difform
RETURN:     the quotient df/dg as differential form 
KEYWORDS:   division
SEE ALSO:   difformMul
EXAMPLE:    example difformDiv; shows an example"
{

    diffAlgebraCheck();
    diffAlgebraSwitch();

    difform ddiv;
    poly div_form = df.form / dg.form;
    ddiv.form = div_form;

    return(ddiv);

}
example
{
"EXAMPLE:"; echo = 2;
ring R = 0,(x,y,z),lp;
diffAlgebra();

/////////////////////////////////
// Divisions without remainder //
/////////////////////////////////

dx / dx;
dx*dy*dz / dz;
(dx*x2 - yx2) / x2;

//////////////////////////////
// Divisions with reaminder //
//////////////////////////////

(dx + dx*dy + 1) / dx;
(x2*dx - x*dy) / (dx-dy);

kill Omega_R,dx,dy,dz;
}


////////////////////////////////////////////////////////////////////////////////////////////////


proc difformEqu(difform df, difform dg)
"USAGE:     df == dg; df,dg difform
RETURN:     1, if df and dg are euqal - 0, otherwise
KEYWORDS:   compare; equal
SEE ALSO:   difformNeq
EXAMPLE:    example difformEqu; shows an example"
{

	diffAlgebraCheck();
    diffAlgebraSwitch();

    return(df.form == dg.form);

}
example
{
"EXAMPLE:"; echo = 2;
ring R = 0,(x,y,z),ds;
diffAlgebra();

/////////////////////////////////////////
// Applications of comparison operator //
/////////////////////////////////////////

difform df = 3*dx - x8*dx*dy;
difform dg = 3 + x8*dy;
df == dg;

dg = dg*dx;
df == dg;

kill Omega_R,df,dg,dx,dy,dz;
}


////////////////////////////////////////////////////////////////////////////////////////////////


proc difformNeq(difform df, difform dg)
"USAGE:     df != dg; df,dg difform
RETURN:     0, if df and dg are euqal - 1, otherwise
KEYWORDS:   compare; equal; not equal
SEE ALSO:   difformEqu
EXAMPLE:    example difformNeq; shows an example"
{

	return(!difformEqu(df,dg));
	
}
example
{
"EXAMPLE:"; echo = 2;
ring R = 0,(x,y,z),ds;
diffAlgebra();

/////////////////////////////////////////////////
// Applications of negated comparison operator //
/////////////////////////////////////////////////

difform df = 3*dx - x8*dx*dy;
difform dg = 3 + x8*dy;
df != dg;

dg = dg*dx;
df != dg;

kill Omega_R,df,dg,dx,dy,dz;
}


////////////////////////////////////////////////////////////////////////////////////////////////


proc difformIsBigger(difform df, difform dg, list #)
"USAGE:     df > dg OR difformIsBigger(df,dg,#); df,dg difform, # list
RETURN:     - 1, if df is bigger than dg with respect to the monomial ordering in the differential algebra - 0, otherwise
            - 1, if df is bigger than dg with respect to a given monomial ordering on the generators/ringvariables - 0, otherwise
NOTE:       the procedure uses diffAlgebraChangeOrd to change the order on the differential algebra, therefore
            an ordering is defined via the following pattern:
                - #[i] = 'gen' defines the ordering on the generators dx_i
                    - #[i+1] must then be a valid monomial ordering as string
                    - #[i+2] an optional weight vector
                - #[i] = 'ringvar' defines the ordering on the ringvariables
                    - #[i+1] must then be a valid monomial ordering as string
                    - #[i+2] an optional weight vector
KEYWORDS:   bigger; compare; ordering
SEE ALSO:   difformIsSmaller, diffAlgebraChangeOrd
EXAMPLE:    example difformIsBigger; shows an example"
{

    diffAlgebraCheck();
    diffAlgebraSwitch();

    poly df_form = df.form;
    poly dg_form = dg.form;

    if(size(#) > 0){
        def diff_Alg = basering;
        ring T = diffAlgebraChangeOrd(#);

        poly df_form_T = imap(diff_Alg,df_form);
        poly dg_form_T = imap(diff_Alg,dg_form);
        return(df_form_T > dg_form_T);
    }

    return(df_form > dg_form);

}
example
{
"EXAMPLE:"; echo = 2;
ring R = 0,(x,y,z),dp;
diffAlgebra();

////////////////////////////
// With standard ordering //
////////////////////////////
dx > dy;
x37*dy > dz;
x*dz > y*x*dy;
x3*dx - y*dx*dz > dx*dy*dz;

///////////////////////////
// With changed ordering //
///////////////////////////
difformIsBigger(dx,dy,"gen","ls");
difformIsBigger(x37*dy,dz,"gen","wp",intvec(1,-1,1));
difformIsBigger(x*dz,y*x*dy,"gen","wp",intvec(1,-1,1),"ringvar","wp",intvec(1,-1,1));
difformIsBigger(x3*dx - y*dx*dz,dx*dy*dz,"gen","wp",intvec(-1,-1,1));

kill Omega_R,dx,dy,dz;
}


////////////////////////////////////////////////////////////////////////////////////////////////


proc difformIsSmaller(difform df, difform dg, list #)
"USAGE:     df < dg OR difformIsSmaller(df,dg,#); df,dg difform, # list
RETURN:     - 1, if df is smaller than dg with respect to the monomial ordering in the differential algebra - 0, otherwise
            - 1, if df is smaller than dg with respect to a given monomial ordering on the generators/ringvariables - 0, otherwise
NOTE:       the procedure uses diffAlgebraChangeOrd to change the order on the differential algebra, therefore
            an ordering is defined via the following pattern:
                - #[i] = 'gen' defines the ordering on the generators dx_i
                    - #[i+1] must then be a valid monomial ordering as string
                    - #[i+2] an optional weight vector
                - #[i] = 'ringvar' defines the ordering on the ringvariables
                    - #[i+1] must then be a valid monomial ordering as string
                    - #[i+2] an optional weight vector
KEYWORDS:   smaller; compare; ordering
SEE ALSO:   difformIsBigger, diffAlgebraChangeOrd
EXAMPLE:    example difformIsSmaller; shows an example"
{

    diffAlgebraCheck();
    diffAlgebraSwitch();
    
    poly df_form = df.form;
    poly dg_form = dg.form;

    if(size(#) > 0){
        def diff_Alg = basering;
        ring T = diffAlgebraChangeOrd(#);

        poly df_form_T = imap(diff_Alg,df_form);
        poly dg_form_T = imap(diff_Alg,dg_form);
        return(df_form_T < dg_form_T);
    }

    return(df.form < dg.form);

}
example
{
"EXAMPLE:"; echo = 2;
ring R = 0,(x,y,z),lp;
diffAlgebra();

////////////////////////////
// With standard ordering //
////////////////////////////
dz < dy;
x*dz < y*dz;
y2*z2*dy < x;
dx*dz < dy;

///////////////////////////
// With changed ordering //
///////////////////////////
difformIsSmaller(dz,dy,"gen","ls");
difformIsSmaller(x*dz,y*dz,"ringvar","ls");
difformIsSmaller(y2*z2*dy,x,"gen","wp",intvec(1,-1,1));
difformIsSmaller(dx*dz,dy,"gen","ws",intvec(1,-1,-1));

kill Omega_R,dx,dy,dz;
}


////////////////////////////////////////////////////////////////////////////////////////////////


proc difformReduce(difform df)
"USAGE:     difformReduce(df); df difform
RETURN:     the differential form df reduced by the zero ideal
NOTE:       - use this procedure if the basering is a quotient ring
            - in case the basering is not a quotient ring, applying
            the procedure has no effect
            - do not use the option 'qringNF'
KEYWORDS:   reduce; reduction
EXAMPLE:    example difformReduce; shows an example"
{

    diffAlgebraCheck();
    diffAlgebraSwitch();
    
    difform df_red;
    poly df_red_form = reduce(df.form,std(0));
    df_red.form = df_red_form;

    return(df_red);

}
example
{
"EXAMPLE:"; echo = 2;
ring S = 0,(x,y,z),lp;
ideal I = x2-y,z2+y,y3-y4;
qring R = std(I);
diffAlgebra();

/////////////////////////////////////
// Reduction of differential forms //
/////////////////////////////////////

difformReduce(z*dx);
difformReduce(dz);
difformReduce(dz*z*dx);
difformReduce(dy + z*dz);

kill Omega_R,dx,dy,dz;
}


////////////////////////////////////////////////////////////////////////////////////////////////
//------------------------- Procedures for computing with the degree -------------------------//
////////////////////////////////////////////////////////////////////////////////////////////////


proc difformDeg(difform df)
"USAGE:     deg(df); df difform
RETURN:     degree of df - degree of the highest generator, -1 if df = 0
NOTE:       - the procedure does not check if df is homogeneous
            - be careful: difformDeg does not cast polynomials to differential 
            forms. So before applying to a polynomial, a type cast should be done
KEYWORDS:   degree
SEE ALSO:   difformIsHomog, difformIsHomogDeg
EXAMPLE:    example difformDeg; shows an example"
{

    diffAlgebraCheck();
    diffAlgebraSwitch();

    // Degree of a difform is the degree of the poly with weights 0 for the basering variables
    int n = size(ringlist(basering)[2]) div 2;
    int i;
    intvec var_weights;
    
    for(i = 1; i <= n; i++){
        var_weights[i] = 1;
        var_weights[i+n] = 0;
    }
    
    return(deg(df.form,var_weights));

}
example
{
"EXAMPLE:"; echo = 2;
ring R = 0,(x,y,z),ds;
diffAlgebra();

/////////////////////////
// Degree computations //
/////////////////////////

deg(3*dx - x8*dx*dy);
deg(3 + x8*dy);

// When applying homog to a polynomial which is considered 
// as a differential form, a type cast has to be done first

deg(x2-y);
difform df = x2-y;
deg(df);

kill Omega_R,df,dx,dy,dz;
}


////////////////////////////////////////////////////////////////////////////////////////////////


proc difformIsHomog(difform df)
"USAGE:     homog(df); df difform
RETURN:     1, if df is homogeneous - 0, otherwise
NOTE:       - the form 0 is homogeneous
            - be careful: difformIsHomog does not cast polynomials to differential 
            forms. So before applying to a polynomial, a type cast should be done
KEYWORDS:   homogeneous; homog
SEE ALSO:   difformDeg, difformIsHomogDeg
EXAMPLE:    example difformIsHomog; shows an example"
{

	diffAlgebraCheck();
    diffAlgebraSwitch();

    int n = size(ringlist(basering)[2]) div 2;
    int i;
    intvec var_weights;
    
    for(i = 1; i <= n; i++){
        var_weights[i] = 1;
        var_weights[i+n] = 0;
    }
    
    return(homog(df.form,var_weights));

}
example
{
"EXAMPLE:"; echo = 2;
ring R = 0,(x,y,z),ds;
diffAlgebra();

/////////////////
// Homogeneous //
/////////////////

homog(3*dx*dz - x8*dx*dy);
homog(12x*dx + dy - (y4-y5)*dz);

/////////////////////
// Not homogeneous //
/////////////////////

homog(3 + x8*dy);
homog(x*dx+dy*dx);

// When applying homog to a polynomial which is considered 
// as a differential form, a type cast has to be done first

homog(3x-y2);
difform df = 3x-y2;
homog(df);

kill Omega_R,dx,dy,dz,df;
}


////////////////////////////////////////////////////////////////////////////////////////////////


proc difformIsHomogDeg(difform df, int p)
"USAGE:     difformIsHomogDeg(df,p); df difform, p int
RETURN:     1, if df is homogeneous of degree p - 0, otherwise
NOTE:       - 0 is homogeneous of degree -1
KEYWORDS:   homogeneous; degree
SEE ALSO:   difformDeg, difformIsHomog
EXAMPLE:    example difformIsHomogDeg; shows an example"
{

	int df_deg = difformDeg(df);
	int is_hom = difformIsHomog(df);
	return(df_deg == p && is_hom == 1);

}
example
{
"EXAMPLE:"; echo = 2;
ring R = 0,(x,y,z),ds;
diffAlgebra();

difform df = 3*dx*dz - x8*dx*dy;
difform dg = 3 + x8*dy;
difform dh = 2;
difform dt = 0;

/////////////////////////////////
// Homogeneous of given degree //
/////////////////////////////////

difformIsHomogDeg(df,2);
difformIsHomogDeg(dh,0);
difformIsHomogDeg(dt,-1);

/////////////////////////////////////
// Not homogeneous of given degree //
/////////////////////////////////////

difformIsHomogDeg(df,1);
difformIsHomogDeg(dg,1);
difformIsHomogDeg(dh,1);

kill Omega_R,df,dg,dh,dt,dx,dy,dz;
}


////////////////////////////////////////////////////////////////////////////////////////////////


proc difformHomogDecomp(difform df)
"USAGE:     difformHomogDec(df); df difform
RETURN:     list of differential forms: homogeneous decomposition
NOTE:       the output list always has as length the maximal possible degree plus one and the
            degree-0 part is the last element in the list
KEYWORDS:   homogeneous; homogeneous decomposition
SEE ALSO:   difformCoef, difformDeg
EXAMPLE:    example difformHomogDec; shows an example"
{

    diffAlgebraCheck();

    // Highest degree is the nr. of variables in the basering
    int n = size(ringlist(basering)[2]);
    int i,j,k;
    difform current_gen;
    poly current_coef;
    list homog_part;

    // Generate a list full of 0s
    for(i = 1;i <= (n+1); i++){
        homog_part[i] = 0;
    }
    
    // Get the generator-representation
    list df_gen_repr = difformCoef(df);
    k = size(df_gen_repr);
    
    // Sort in list
    for(i = 1; i <= k; i++){
        current_gen = df_gen_repr[i][1];
        current_coef = df_gen_repr[i][2];
        j = difformDeg(current_gen);
    
        if(j == 0){
            homog_part[n+1] = homog_part[n+1] + current_coef*current_gen;
        }else{
            homog_part[j] = homog_part[j] + current_coef*current_gen;
        }
    }

    return(homog_part);

}
example
{
"EXAMPLE:"; echo = 2;
ring R = 0,(x,y,z),ds;
diffAlgebra();

difform df = 3*dx*dz - x8*dx*dy + 12 + dy*dz + dz*dx - (y4-y5)*x12*dx*dy*dz - dx - dy + dz + x2*dx*dy;

///////////////////////////////
// Homogeneous decomposition //
///////////////////////////////

list L = difformHomogDecomp(df);
L;

kill Omega_R,df,L,dx,dy,dz;
}


////////////////////////////////////////////////////////////////////////////////////////////////
//------------------------ Procedures for lists of differential forms ------------------------//
////////////////////////////////////////////////////////////////////////////////////////////////


proc difformListContains(list L, difform df, list #)
"USAGE:     difformListContains(L,df); L list, df difform
RETURN:     - 1, if df is in the list L - 0, otherwise
            - the index of df in L - 0, if df is not in the list
NOTE:       - to get the index of the searched element, use #[1] = "index"
            - lists with elements of type 'difform' or types that convert to
            'difform' are allowed
KEYWORDS:   containment; list
SEE ALSO:   difformEqu
EXAMPLE:    example difformListContains; shows an example"
{

    diffAlgebraCheck();

    int n = size(L);
    int i;
    int index_flag = 0;

    if(size(#) > 0){
        if(typeof(#[1]) == "string"){
            if(#[1] == "index"){
                index_flag = 1;
            }
        }
    }
    
    for(i = 1; i <= n; i++){
        if(df == L[i]){
            if(index_flag == 1){
                // Return index
                return(i);
            }else{
                // Return bool
                return(1);
            }
        }
    }

    return(0);
    
}
example
{
"EXAMPLE:"; echo = 2;
ring R = 17,(a,b,c),lp;
diffAlgebra();

list L = db,3,12*a,da-db,16 + dc, 23*da - 4*db*dc*da, db - 4, 2, dc - db*da, a;

//////////////////////////
// Elements in the list //
//////////////////////////
difformListContains(L,da - db);
difformListContains(L,16 + dc);
difformListContains(L,dc - db*da);

// With index
difformListContains(L,16 + dc,"index");

//////////////////////////////
// Elements not in the list //
//////////////////////////////
difformListContains(L,22*da);
difformListContains(L,1);
difformListContains(L,dc);

// Index is 0, if element is not in list
difformListContains(L,1,"index");

kill Omega_R,L,da,db,dc;
}


////////////////////////////////////////////////////////////////////////////////////////////////


proc difformListSort(list L, list #)
"USAGE:     difformListSort(L,#); L,# list
RETURN:     the sorted list L in ascending order, depending on the optional monomial ordering given
REMARKS:    Classical insertion sort is used to sort the list
NOTE:       - the procedure uses difformIsBigger to compare list elements, therefore
            an optional ordering is defined via the pattern in difformIsBigger
            - the standard ordering is the ordering on the differential algebra
            - the procedure can also handle special lists of lists by using the optional input 
            "Dlist" or "Llist":
                - "Dlist" is used for lists with structure: 
                    L[1] is a list of differential forms
                    L[2] is a list of polynomials of same size, 
                The list gets sorted by the elements in L[1]. This is mainly used for the 
                structure of derivations.
                - "Llist" allows the structure: L[i] is a list with two entries:
                    L[i][1] is a differential form
                    L[i][2] is a polynomial
                The list gets sorted by the elements L[i][1]. This is used to sort
                coefficient lists.
KEYWORDS:   sort; list
SEE ALSO:   difformIsBigger, difformIsSmaller
EXAMPLE:    example difformListSort; shows an example"
{

    diffAlgebraCheck();
    
    list orderings = #;
    int n = size(orderings);
    int i,j;
    int Dlist_flag = 0;
    int Llist_flag = 0;
    
    // Check for double list
    for(i = 1; i <= n; i++){
        if(typeof(orderings[i]) == "string"){
            if(orderings[i] == "Dlist"){
                Dlist_flag = 1;
                orderings = delete(orderings,i);
            }
        }
    }
    
    // Check for list of lists
    for(i = 1; i <= n; i++){
        if(typeof(orderings[i]) == "string"){
            if(orderings[i] == "Llist"){
                Llist_flag = 1;
                orderings = delete(orderings,i);
            }
        }
    }

    // Not both list forms allowed
    if(Dlist_flag == 1 && Llist_flag == 1){
        ERROR("Cannot sort double list of lists!");
    }

    // Double list detected
    if(Dlist_flag == 1){
        poly temp_form_sec;
        list L_sec = L[2];
        L = L[1];
    }

    // List of lists detected
    if(Llist_flag == 1){
        poly temp_form_sec;
        n = size(L);
        list L_temp;
        list L_sec;

        // Transform list of lists to double list
        for(i = 1; i <= n; i++){
            L_temp[i] = L[i][1];
            L_sec[i] = L[i][2];
        }

        L = L_temp;
    }

    // Insertion sort
    difform temp_form;
    n = size(L);

    for(i = 1; i <= n; i++){
        temp_form = L[i];

        if(Dlist_flag == 1 || Llist_flag == 1){
            temp_form_sec = L_sec[i];
        }

        j = i;

        while(j > 1){
            if(difformIsBigger(L[j-1],temp_form,orderings)){
                L[j] = L[j-1];

                if(Dlist_flag == 1 || Llist_flag == 1){
                    L_sec[j] = L_sec[j-1];
                }

                j--;
            }else{
                break;
            }
        }

        L[j] = temp_form;

        if(Dlist_flag == 1 || Llist_flag == 1){
            L_sec[j] = temp_form_sec;
        }
    }

    // For double list - return a double list
    if(Dlist_flag == 1){
        return(list(L,L_sec));
    }

    // For list of lists - return a list of lists
    if(Llist_flag == 1){
        L_temp = list();
        for(i = 1; i <= n; i++){
            L_temp[i] = list(L[i],L_sec[i]);
        }

        return(L_temp);
    }

    return(L);

}
example
{
"EXAMPLE:"; echo = 2;
ring R = 0,(x,y,z,t),dp;
diffAlgebra();

/////////////////////////
// Sortation of a list //
/////////////////////////

list L = dx*x, x2 - y*t, 12, dt*dy*dx*dz;

// Sort list with standard ordering
difformListSort(L);
// Sort list with changed ordering
difformListSort(L,"gen","ls","ringvar","wp",intvec(-1,1,1,1));

/////////////////////////////////////////////
// Sortation of list with strcture "Dlist" //
/////////////////////////////////////////////

list DL;
DL[1] = list(dx,x,t,dt); DL[2] = list(y,t*z,4,x);

// This list has the structure described by "Dlist"
difformListSort(DL,"Dlist","ringvar","ls");

/////////////////////////////////////////////
// Sortation of list with strcture "Llist" //
/////////////////////////////////////////////

list LL; 
LL[1] = list(dx,x); LL[2] = list(t*dt,y); LL[3] = list(x,2);

// This list has the structure described by "Llist"
difformListSort(LL,"Llist");

kill Omega_R,dx,dy,dz,dt,L,DL,LL;
}


///////////////////////////////////////////////////////////////////////////////////
//------------ Procedures for computing with the universal derivation -----------//
///////////////////////////////////////////////////////////////////////////////////


proc difformUnivDer(poly f)
"USAGE:     difformUnivDer(f); f poly
RETURN:     a differential form: the image of the universal derivation applied to f
KEYWORDS:   derivation; universal
SEE ALSO:   difformDiff
EXAMPLE:    example difformUnivDer; shows an example"
{
    
    diffAlgebraCheck();
    
	difform df = 0;
    difform d_var;
	int n = size(ringlist(basering)[2]);
	int i;

	// Build the image under the universal derivation
	for(i = 1; i <= n; i++){
        execute("d_var = d" + string(var(i)));
		df = df + diff(f,var(i))*d_var;
	}
	
	return(df);

}
example
{
"EXAMPLE:"; echo = 2;
ring R = 0,(x,y,z),lp;
diffAlgebra();

/////////////////////////////////////////////////
// Universal derivation applied to polynomials //
/////////////////////////////////////////////////

difformUnivDer(3x);
difformUnivDer(xyz+x2y2z2);
difformUnivDer(x+y+z);

kill Omega_R,dx,dy,dz;
}


////////////////////////////////////////////////////////////////////////////////////////////////


proc difformDiff(difform df)
"USAGE:     difformDiff(df); df difform
RETURN:     the image of df under the differential
REMARKS:    To compute the image, the universal derivation is applied to each coefficient and multiplied with the
            corresponding generator
NOTE:       - the differential is a map Omega_R^(p) -> Omega_R^(p+1) and this procedure applies
            the differential to all homogeneous parts of df
            - this procedure can also be apllied to polynomials - in this case it is just the universal derivation
KEYWORDS:   differential; universal; derivation
SEE ALSO:   difformUnivDer
EXAMPLE:    example difformDiff; shows an example"
{
 
    diffAlgebraCheck();

    difform d_df = 0;
    list df_gen_repr = difformCoef(df);
    int n = size(df_gen_repr);
    int i;
    
    // Derivate each coefficient
    for(i = 1; i <= n; i++){
        d_df = d_df + difformUnivDer(df_gen_repr[i][2])*df_gen_repr[i][1];
    }

    return(d_df);

}
example
{
"EXAMPLE:"; echo = 2;
ring R = 0,(x,y,z,a,b,c),lp;
diffAlgebra();

////////////////////////////////////////
// Construction of differential forms //
////////////////////////////////////////

difform df_1 = y*dx + z*dy + x*dz + a*db + b*dc + c*da;
difform df_2 = -5*c4*dc*dz*dy + 3*dx*dz - 13*a4*da*db + 12*a4*da*db + x8*dx*dy + 12 + dy*da + dz*dx - (y4-y5)*x12*dx*db*dz - dx - dy + db + x2*db*dy;
poly f = 3x2y2 - z3*c;

///////////////////////////////////////
// Differential applied to the forms //
///////////////////////////////////////

difformDiff(df_1);
difformDiff(df_2);
difformDiff(f);

// The composition of differentials is the zero-map:
difformDiff(difformDiff(df_1)); 

kill Omega_R,df_1,df_2,f,dx,dy,dz,da,db,dc;
}


////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
//                               Procedures for type derivation                               //
////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////
//-------------------------------- Type casts and constructor --------------------------------//
////////////////////////////////////////////////////////////////////////////////////////////////


static proc derivationFromList(list L)
"USAGE:     derivationFromList(L); L list
RETURN:     the derivation defined by the list L
REMARKS:    The structure of L is checked and L is sorted,
            then it is set as structure list of phi
NOTE:       the structure of L must follow the rules:
                - L[1] is a list of all degree-1 generators: all dx_i must occure once and no other 
                differential forms are allowed. The order of the list is not important
                - L[2] is the list of images of the dx_i: these must be polynomials
            Since the map is linear, it is enough to store the images of the dx_i
KEYWORDS:   constructor; derivation; list
SEE ALSO:   derivationCheckList, derivationFromType"
{
    
    // Check the structure of the given list
    derivationCheckList(L);   

    // Sort the generators by the monomial ordering given in the differential algebra
    L = difformListSort(L,"Dlist");

    derivation phi;
    phi.genIm = L;
    
    return(phi);
    
}


////////////////////////////////////////////////////////////////////////////////////////////////


static proc derivationCheckList(list L)
"USAGE:     derivationCheckList(L); L list
REMARKS:    The procedure checks if a given list has the right form for a derivation
            and throws an error if this is not the case. In particular:
                - Only degree-1 generators are allowed in L[1] - this is checked via difformIsGen
                - Any degree-1 generator must occur once - this is checked via difformListContains
NOTE:       like in derivationFromList, the structure of L must follow the rules:
                - L[1] is a list of all degree-1 generators: all dx_i must occure once and no other 
                differential forms are allowed. The order of the list is not important
                - L[2] is the list of images of the dx_i: these must be polynomials
KEYWORDS:   constructor; derivation; structure; list
SEE ALSO:   derivationFromList, difformIsGen, difformListContains"
{

    if(size(L) != 2){
        ERROR("Given list has wrong size!");
    }

    if(typeof(L[1]) != "list" || typeof(L[2]) != "list"){
        ERROR("Given list does not contain lists!");
    }

    if(size(L[1]) != size(L[2])){
        ERROR("Given list does not have the right form!");
    }

    int n = size(L[1]);
    int i;

    // Need an image for any generator
    if(n != size(ringlist(basering)[2])){
        ERROR("Given list has wrong size!");
    }
    
    for(i = 1; i <= n; i++){
        // Right type needed
        if((typeof(L[1][i]) != "difform" && typeof(L[1][i]) != "difvar") || (typeof(L[2][i]) != "poly" && typeof(L[2][i]) != "int" && typeof(L[2][i]) != "bigint" && typeof(L[2][i]) != "number")){
            ERROR("Given list contains wrong type!");
        }
        
        // Generator of Omega_R^1
        if(!(difformIsGen(L[1][i]) && deg(L[1][i]) == 1)){
            ERROR("Given list contains a non-generator or a generator not of degree 1!");
        }
    }
    
    // Now check the list L[1] for duplicates of the generators
    list L_i;
    for(i = 1; i <= n; i++){
        L_i = delete(L[1],i);
        if(difformListContains(L_i,L[1][i])){
            ERROR("Given list contains duplicate of a generator!");
        }
    }
}


////////////////////////////////////////////////////////////////////////////////////////////////


proc derivationFromType(def t_in)
"USAGE:     derivation phi = t_in; t_in of any type
RETURN:     the derivation defined by t_in
NOTE:       - the type list defines derivataions
            - if a list is given, it must satisfy:
                - L[1] is a list of all degree-1 generators: all dx_i must occure once and no other 
                differential forms are allowed. The order of the list is not important
                - L[2] is the list of images of the dx_i: these must be polynomials
KEYWORDS:   constructor; derivation
SEE ALSO:   derivationFromList
EXAMPLE:    example derivationFromType; shows an example"
{
    diffAlgebraCheck();
    derivation phi;
    string NL = newline + tab(5);
    
    while(1){
        // Allowed types
        if(typeof(t_in) == "list"){ phi = derivationFromList(t_in); break; }
        // Wrong type
        ERROR("Wrong type - expected type:" + NL + "list");
    }

    return(phi);

}
example
{
"EXAMPLE:"; echo = 2;
ring R = 31,(x,y,z),dp;
diffAlgebra();

////////////////////////////////////////////////////////////
// Construction of derivations from lists and polynomials //
////////////////////////////////////////////////////////////

list L; L[1] = list(dx,dz,dy); L[2] = list(x2,y-x,z);
derivation phi = L; phi;

kill Omega_R,dx,dy,dz,phi,L;
}


////////////////////////////////////////////////////////////////////////////////////////////////


proc derivationToString(derivation phi, list #)
"USAGE:     derivationToString(phi,#); phi derivation, # list
RETURN:     the derivation as a string, describing the image of the degree-1 generators,
            optionally ordered by a given monomial ordering on the generators
REMARKS:    To sort the images of the generators in the output string, difformListSort is used.
NOTE:       to define an ordering for the generators, one can use:
                - #[1] = 'gen'
                - #[2]: a monomial ordering as string
                - #[3]: an optional weight vector
            the standard ordering is the ordering of the differential algebra
KEYWORDS:   string; print
SEE ALSO:   derivationPrint, difformListSort, difformGenToString
EXAMPLE:    example derivationToString; shows an example"
{

    diffAlgebraCheck();
    list temp_genIm = phi.genIm;
    
    // Get the optional ordering on the generators
    string gen_ord = "";
    int n = size(#);
    int i;
    
    for(i = 1; i <= n; i++){
        if(typeof(#[i]) == "string"){
            if(#[i] == "gen" && typeof(#[i+1]) == "string"){
                gen_ord = #[i+1];
                if(typeof(#[i+2]) == "intvec"){
                    intvec gen_weight = #[i+2];
                }
            }
        }
    }
    
    // Sort the generator/coefficients by the chosen ordering
    if(gen_ord != ""){
        if(defined(gen_weight) >= 2){
            temp_genIm = difformListSort(temp_genIm,"Dlist","gen",gen_ord,gen_weight);
        }else{
            temp_genIm = difformListSort(temp_genIm,"Dlist","gen",gen_ord);
        }
    }
    
    list gens = temp_genIm[1];
    list images = temp_genIm[2];
    n = size(gens);

    // Transform to string
    string ring_name = nameof(basering);
    string phi_out = " Omega_" + ring_name + "^1 --> " + ring_name + newline;
    int ring_name_size = size(ring_name);
    
    for(i = 1; i <= n; i++){
        phi_out = phi_out + tab(6 + ring_name_size) + difformGenToString(gens[i]) + " |--> " + string(images[i]) + newline;
    }
    
    return(phi_out);

}
example
{
"EXAMPLE:"; echo = 2;
ring R = 0,(x,y,z),dp;
diffAlgebra();

list L; L[1] = list(dx,dy,dz); L[2] = list(x2,y-23xz,xz4);
derivation phi = L;

///////////////////////////////////
// String with standard ordering //
///////////////////////////////////

print(derivationToString(phi));

//////////////////////////////////
// String with changed ordering //
//////////////////////////////////

print(derivationToString(phi,"gen","wp",intvec(-1,-1,1)));

kill Omega_R,dx,dy,dz,L,phi;
}


////////////////////////////////////////////////////////////////////////////////////////////////
//----------------------------------- Structural procedures ----------------------------------//
////////////////////////////////////////////////////////////////////////////////////////////////


proc derivationPrint(derivation phi)
"USAGE:         phi; phi derivation
SIDE EFFECTS:   Prints the given derivation.
REMARKS:        Prints the string returned by derivationToString with a ls-ordering on the generators
KEYWORDS:       print; string
SEE ALSO:       derivationToString
EXAMPLE:        example derivationPrint; shows an example"
{

    // Orders the generators in ls-order
    print(derivationToString(phi,"gen","ls"));

}
example
{
"EXAMPLE:"; echo = 2;
ring R = 0,(a,b,c,x,y,z),lp;
diffAlgebra();

////////////////
// Derivation //
////////////////

list L; L[1] = list(dx,dy,dz,da,db,dc); L[2] = list(1,12x-y,z4aby, 2*b5x,0,xyz-abc);
derivation phi = L;

//////////////////////////
// Application of Print //
//////////////////////////

phi;

kill Omega_R,da,db,dc,dx,dy,dz,L,phi;
}


////////////////////////////////////////////////////////////////////////////////////////////////
//------------------------------ Basic computational procedures ------------------------------//
////////////////////////////////////////////////////////////////////////////////////////////////


proc derivationAdd(derivation phi, derivation psi)
"USAGE:     phi+psi; phi,psi derivation
RETURN:     the sum of the given derivations
REMARKS:    The sum is computed componentwise - this works since the structure lists
            of derivations are sorted the same way.
NOTE:       once can also add polynomials and derivations
KEYWORDS:   add; sum
SEE ALSO:   derivationSub
EXAMPLE:    example derivationAdd; shows an example"
{
    
    diffAlgebraCheck();

    // Structure for derivation
    derivation add_der;
    list add_list;
    add_list[1] = list();
    add_list[2] = list();
    add_list[1] = phi.genIm[1];

    int n = size(add_list[1]);
    int i;

    for(i = 1; i <= n; i++){
        // Lists are sorted the same way
        add_list[2][i] = phi.genIm[2][i] + psi.genIm[2][i];
    }

    // The list is already sorted
    add_der.genIm = add_list;
    return(add_der);

}
example
{
"EXAMPLE:"; echo = 2;
ring R = 0,(x,y,z),ds;
diffAlgebra();

list L_1; L_1[1] = list(dx,dy,dz); L_1[2] = list(2x,2y,2z);
list L_2; L_2[1] = list(dx,dy,dz); L_2[2] = list(y2-x,z4+x+y,y2);

/////////////////
// Derivations //
/////////////////

derivation phi_1 = L_1; phi_1;
derivation phi_2 = L_2; phi_2;

////////////////////////
// Sum of derivations //
////////////////////////

phi_1 + phi_2;
phi_1 + phi_2 + phi_2;

kill Omega_R,dx,dy,dz,L_1,L_2,phi_1,phi_2;
}


////////////////////////////////////////////////////////////////////////////////////////////////


proc derivationSub(derivation phi, derivation psi)
"USAGE:     phi-psi; phi,psi derivation
RETURN:     the difference of the given derivations
REMARKS:    The difference is computed componentwise - this works since the 
            structure lists of derivations are sorted the same way.
NOTE:       one can also subtract polynomials from derivations
KEYWORDS:   minus; difference
SEE ALSO:   derivationAdd, derivationNeg
EXAMPLE:    example derivationSub; shows an example"
{
    
    diffAlgebraCheck();

    // Structure for derivation
    derivation sub_der;
    list sub_list;
    sub_list[1] = list();
    sub_list[2] = list();
    sub_list[1] = phi.genIm[1];

    int n = size(sub_list[1]);
    int i;

    for(i = 1; i <= n; i++){
        // Lists are sorted the same way
        sub_list[2][i] = phi.genIm[2][i] - psi.genIm[2][i];
    }

    // The list is already sorted
    sub_der.genIm = sub_list;
    return(sub_der);

}
example
{
"EXAMPLE:"; echo = 2;
ring R = 0,(x,y),lp;
diffAlgebra();

list L_1; L_1[1] = list(dx,dy); L_1[2] = list(x+y,1);
list L_2; L_2[1] = list(dy,dx); L_2[2] = list(x,y2);

/////////////////
// Derivations //
/////////////////

derivation phi_1 = L_1; phi_1;
derivation phi_2 = L_2; phi_2;

///////////////////////////////
// Difference of derivations //
///////////////////////////////

phi_1-phi_2;
phi_1-phi_2-phi_1;

kill Omega_R,dx,dy,L_1,L_2,phi_1,phi_2;
}


////////////////////////////////////////////////////////////////////////////////////////////////


proc derivationNeg(derivation phi)
"USAGE:     -phi; phi derivation
RETURN:     the negation of a given derivation
KEYWORDS:   minus; difference
SEE ALSO:   derivationSub
EXAMPLE:    example derivationNeg; shows an example"
{

    diffAlgebraCheck();

    // Structure for derivation
    derivation neg_der;
    list neg_list;
    neg_list[1] = list();
    neg_list[2] = list();
    neg_list[1] = phi.genIm[1];

    int n = size(neg_list[1]);
    int i;

    for(i = 1; i <= n; i++){
        neg_list[2][i] = -phi.genIm[2][i];
    }

    // The list is already sorted
    neg_der.genIm = neg_list;
    return(neg_der);

}
example
{
"EXAMPLE:"; echo = 2;
ring R = 0,(x,y,z,t),dp;
diffAlgebra();

list L_1; L_1[1] = list(dy,dx,dt,dz); L_1[2] = list(x2-y,23y+t,tz4,z-y);

////////////////
// Derivation //
////////////////

derivation phi_1 = L_1; phi_1;

////////////////////////////
// Negation of derivation //
////////////////////////////

-phi_1;
-(-phi_1);

kill Omega_R,dx,dy,dz,dt,L_1,phi_1;
}


////////////////////////////////////////////////////////////////////////////////////////////////


proc derivationMul(poly f, derivation psi)
"USAGE:     f*psi; psi derivation
RETURN:     the product of f and psi
REMARKS:    f is multiplied to psi componentwise
NOTE:       - this models the module structure of the module of derivations
            - polynomials can only be multiplied from left
KEYWORDS:   derivation scalar multiplication
EXAMPLE:    derivationMul; shows an example"
{
    
    diffAlgebraCheck();

    // Structure for derivation
    derivation mul_der;
    list mul_list;
    mul_list[1] = list();
    mul_list[2] = list();
    mul_list[1] = psi.genIm[1];

    int n = size(mul_list[1]);
    int i;

    for(i = 1; i <= n; i++){
        mul_list[2][i] = f*psi.genIm[2][i];
    }

    // The list is already sorted
    mul_der.genIm = mul_list;
    return(mul_der);

}
example
{
"EXAMPLE:"; echo = 2;
ring R = 0,(a,b,t),ls;
diffAlgebra();

list L_1; L_1[1] = list(da,dt,db); L_1[2] = list(2a,2t-b,2t);
list L_2; L_2[1] = list(dt,db,da); L_2[2] = list(-a,-b,-t);

/////////////////
// Derivations //
/////////////////

derivation phi_1 = L_1; phi_1;
derivation phi_2 = L_2; phi_2;

////////////////////////////////////////////////////
// Multiplication of derivations with polynomials //
////////////////////////////////////////////////////

(a2b3t4)*phi_2;
(a-b+t)*phi_2;
a*phi_1 + b*phi_2;

kill Omega_R,da,db,dt,L_1,L_2,phi_1,phi_2;
}


////////////////////////////////////////////////////////////////////////////////////////////////


proc derivationEqu(derivation phi, derivation psi)
"USAGE:     phi == psi; phi,psi derivation
RETURN:     1, if phi and psi are equal - 0, otherwise
REMARKS:    The images of the generators are compared compononentwise - this 
            works since the structure lists of derivations are sorted the same way.
NOTE:       derivations can also be compared to polynomials
KEYWORDS:   compare; equal
SEE ALSO:   derivationNeq
EXAMPLE:    example derivationEqu; shows an example"
{
    
    diffAlgebraCheck();

    int n = size(phi.genIm[1]);
    int i;

    for(i = 1; i <= n; i++){
        // Lists are sorted the same way
        if(phi.genIm[2][i] != psi.genIm[2][i]){
            // Different images
            return(0);
        }
    }

    // Images are the same
    return(1);

}
example
{
"EXAMPLE:"; echo = 2;
ring R = 0,(u,v),lp;
diffAlgebra();

list L_1; L_1[1] = list(dv,du); L_1[2] = list(u,-v);
list L_2; L_2[1] = list(dv,du); L_2[2] = list(-u,v);

/////////////////
// Derivations //
/////////////////

derivation phi_1 = L_1; phi_1;
derivation phi_2 = L_2; phi_2;

///////////////////////////////
// Comparison of derivations //
///////////////////////////////

phi_1 == phi_1;
phi_1 == phi_2;
phi_1 == -phi_2;

kill Omega_R,du,dv,phi_1,phi_2;
}


////////////////////////////////////////////////////////////////////////////////////////////////


proc derivationNeq(derivation phi, derivation psi)
"USAGE:     phi != psi; phi,psi derivation
RETURN:     0, if phi and psi are equal - 1, otherwise
REMARKS:    The comparison is done by difformEqu
NOTE:       derivations can also be compared to polynomials
KEYWORDS:   compare; equal; not equal
SEE ALSO:   derivationEqu
EXAMPLE:    example derivationNeq; shows an example"
{
    
    return(!derivationEqu(phi,psi));

}
example
{
"EXAMPLE:"; echo = 2;
ring R = 0,(u,v),lp;
diffAlgebra();

list L_1; L_1[1] = list(dv,du); L_1[2] = list(u,-v);
list L_2; L_2[1] = list(dv,du); L_2[2] = list(-u,v);

/////////////////
// Derivations //
/////////////////

derivation phi_1 = L_1; phi_1;
derivation phi_2 = L_2; phi_2;

///////////////////////////////
// Comparison of derivations //
///////////////////////////////

phi_1 != phi_1;
phi_1 != phi_2;
phi_1 != -phi_2;

kill Omega_R,du,dv,phi_1,phi_2;
}


////////////////////////////////////////////////////////////////////////////////////////////////


proc derivationEval(derivation phi, difform df)
"USAGE:     phi(df); phi derivation, df difform
RETURN:     the polynomial phi(df), the derivation phi evaluated at df
REMARKS:    - By linearity it is enough to compute the sum of all differential forms:
                (coefficient of dx_i)*(image of dx_i)
            - The coefficient list of df is computed via difformCoef
            - To avoid searching generators in lists, the coefficient list of df and the
            structure list of phi are sorted the same way
NOTE:       - the differential form 0 is allowed as input
            - an error will occure if the given differential form is not of degree 1 or -1
KEYWORDS:   evaluation; derivation; application
SEE ALSO:   difformListSort, difformCoef
EXAMPLE:    example derivationEval; shows an example"
{

    diffAlgebraCheck();

    if(!homog(df)){
        ERROR("Cannot apply derivation to non-homogeneous element!");
    }

    if(deg(df) != 1 && deg(df) != -1){
        ERROR("Cannot apply derivation to differential form not of degree 1!");
    }

    poly df_eval = 0;
    list df_gen_repr = difformListSort(difformCoef(df),"Llist");
    int k = size(df_gen_repr);
    int n = size(phi.genIm[1]);
    int i;
    int j = 1;

    for(i = 1; i <= n; i++){
        // Both lists are sorted by the monomial ordering on the differential algebra
        // So the generators are sorted the same way in both lists
        // If given df does not involve all generators, avoid gaps using j    
        if(j <= k){
            if(df_gen_repr[j][1] == phi.genIm[1][i]){
                df_eval = df_eval + df_gen_repr[j][2]*phi.genIm[2][i];
                j++;
            }
        }
    }

    return(df_eval);

}
example
{
"EXAMPLE:"; echo = 2;
ring R = 13,(x,y,z,t),dp;
diffAlgebra();

/////////////////////////////////
// Construction of derivations //
/////////////////////////////////

list L_1; L_1[1] = list(dx,dt,dz,dy); L_1[2] = list(x,y,z,t);
derivation phi_1 = L_1; phi_1;

list L_2; L_2[1] = list(dx,dy,dz,dt); L_2[2] = list(y2x-zt,zt + y, t3-x, y4-y5);
derivation phi_2 = L_2; phi_2;

list L_3; L_3[1] = list(dx,dy,dz,dt); L_3[2] = list(0,0,0,0);
derivation phi_3 = L_3; phi_3;

///////////////////////////////
// Evaluation of derivations //
///////////////////////////////

phi_1(0);
phi_1(dx+dy+dz+dt);
phi_1(3*dx - dt);

phi_2(dt);
phi_2(dx+dt);
phi_2(dx - dy + (x3-y2)*dz + 12*dt);

phi_3(dx);
phi_3(dy);
phi_3(dx - 24*(dx + dz) - x4*dy);

kill Omega_R,dx,dy,dz,dt,L_1,L_2,L_3,phi_1,phi_2,phi_3;
}


////////////////////////////////////////////////////////////////////////////////////////////////
//----------------------- Procedures for computing the Lie-Derivative ------------------------//
////////////////////////////////////////////////////////////////////////////////////////////////


static proc difformContractionGen(derivation phi, difform d_gen)
"USAGE:     difformContractionGen(phi,d_gen); phi derivation, d_gen difform
ASSUME:     d_gen is a generator of the differential algebra
RETURN:     the image of d_gen under the contraction map i_phi
REMARKS:    The formula for the contraction map applied to a generator of degree l is given by:
            i_phi^(l)(dx_k*...*dx_j) = sum(i=1,..l)(-1)^(i+1) * phi(dx_i) * (dx_k*...*dx_j / dx_i)
NOTE:       this procedure should only be applied to generators
KEYWORDS:   contraction; generator
SEE ALSO:   difformContraction"
{

    // Sort the list, that dx_1 is the first form, dx_2 the second,...
    list gen_list = phi.genIm[1];
    gen_list = difformListSort(gen_list,"gen","ls");

    int n = size(gen_list);
    int j = 1;
    int i;
    difform applic = 0;
    
    // Go through all degree-1 generators and test if, dx_i occurs in d_gen
    for(i = 1; i <= n; i++){
        if(d_gen / gen_list[i] != 0){
            applic = applic + ((-1)^(j+1))*derivationEval(phi,gen_list[i])*(d_gen/gen_list[i]);
            j++;
        }
    }

    return(applic);

}


////////////////////////////////////////////////////////////////////////////////////////////////


proc difformContraction(derivation phi, difform df)
"USAGE:     difformContraction(phi,df); phi derivation, df difform
RETURN:     the image of df under the contraction of phi
REMARKS:    Since the contraction map is linear, it is only applied to the generators: 
            So the image of df is a sum, where the coefficients are multiplied
            by the image of the generators.
NOTE:       over the basering, the contraction map is the 0-map
KEYWORDS:   contraction
SEE ALSO:   difformContraction, difformLieDer
EXAMPLE:    example difformContraction; shows an example"
{

    diffAlgebraCheck();

    list coef_list = difformCoef(df);
    int k = size(coef_list);
    int i;
    difform applic = 0;

    // Apply the contraction map to the generators since it is linear
    for(i = 1; i <= k; i++){
        applic = applic + coef_list[i][2]*difformContractionGen(phi,coef_list[i][1]);
    }

    return(applic);

}
example
{
"EXAMPLE:"; echo = 2;
ring R = 0,(x,y,z),lp;
diffAlgebra();

/////////////////////////////////
// Construction of derivations //
/////////////////////////////////

list L_1; L_1[1] = list(dx,dy,dz); L_1[2] = list(x,y,z);
derivation phi_1 = L_1; phi_1;

list L_2; L_2[1] = list(dx,dy,dz); L_2[2] = list(y-x,z-y,x-z);
derivation phi_2 = L_2; phi_2;


/////////////////////////////////
// Contractions of derivations //
/////////////////////////////////

difformContraction(phi_1,dx+dy+dz);
difformContraction(phi_1,x2*y4-z);
difformContraction(phi_1,x2*dx*dy + dx*dy*dz);

difformContraction(phi_2,dx+dy+dz);
difformContraction(phi_2,dx*dy*dz - dx*dy + dx*dz);

kill Omega_R,dx,dy,dz,L_1,L_2,phi_1,phi_2;
}


////////////////////////////////////////////////////////////////////////////////////////////////


proc difformLieDer(derivation phi, difform df)
"USAGE:     diff(phi,df); phi derivation, df difform
RETURN:     the image of df under the Lie-derivative of phi
REMARKS:    The Lie-derivative is the anticommutator of the contraction map of phi
            and the universal derivation d:
                (i_phi o d) + (d o i_phi)
KEYWORDS:   Lie; contraction
SEE ALSO:   difformContraction, difformDiff
EXAMPLE:    example difformLieDer; shows an example"
{

    difform lie_form = difformContraction(phi,difformDiff(df)) + difformDiff(difformContraction(phi,df));
    return(lie_form);

}
example
{
"EXAMPLE:"; echo = 2;
ring R = 0,(x,y,z),lp;
diffAlgebra();

////////////////////////////////
// Construction of derivation //
////////////////////////////////

list L; L[1] = list(dx,dy,dz); L[2] = list(x2,y2,z2);
derivation phi = L; phi;

///////////////////////////////////
// Lie-derivative of derivations //
///////////////////////////////////

diff(phi,dx);
diff(phi,dx*dy);
diff(phi,dx*dy*dz);
diff(phi,dx*dy + dy*dx);
diff(phi,dx*dy - dy*dx);

kill Omega_R,dx,dy,dz,L,phi;
}


////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
//                                       Test examples                                        //
////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////


// EXAMPLE: differential algebra over ring of characteristic 0
proc diffAlgebra_example_1(){
    ring R = 0,(x,y,z),dp;
    diffAlgebra();
    
    exportto(Top,R);
}


////////////////////////////////////////////////////////////////////////////////////////////////


// EXAMPLE: differential algebra over big ring of characteristic 0 and block ordering
proc diffAlgebra_example_2(){
    ring R = 0,(a,b,x,y,z,t,s,e,r,w,i),(ls(3),dp(4),lp);
    diffAlgebra();
    
    exportto(Top,R);
}


////////////////////////////////////////////////////////////////////////////////////////////////


// EXAMPLE: differential algebra over ring of positive characteristic
proc diffAlgebra_example_3(){
    ring R = 31,(a,b,x),dp;
    diffAlgebra();
    
    exportto(Top,R);
}


////////////////////////////////////////////////////////////////////////////////////////////////


// EXAMPLE: differential algebra over quotient ring
proc diffAlgebra_example_4(){
    ring S = 0,(x,y,z),lp;
    ideal I = x2-y4,xyz;
    qring R = std(I);
    diffAlgebra();
    
    exportto(Top,R);
}


////////////////////////////////////////////////////////////////////////////////////////////////


// EXAMPLE: differential algebra over quotient ring in positive characteristic
proc diffAlgebra_example_5(){
    ring S = 31,(x,y,z),lp;
    ideal I = x+y+z,xyz;
    qring R = std(I);
    diffAlgebra();
    
    exportto(Top,R);
}


////////////////////////////////////////////////////////////////////////////////////////////////


// EXAMPLE: differential algebra over quotient ring - big example
proc diffAlgebra_example_6(){
    ring S = 0,(x,y,z),dp;
    ideal I = x37y46z12 - y34, x12y17 + z18, x24y12z16;
    qring R = std(I);
    diffAlgebra();

    exportto(Top,R);
}


////////////////////////////////////////////////////////////////////////////////////////////////


// EXAMPLE: differential algebra over quotient ring with block ordering
proc diffAlgebra_example_7(){
    ring S = 0,(x,y,z,a,b),(lp(2),dp(2),ds);
    ideal I = 3x2y2-ab,z4 + a2b2, yz2+a5;
    qring R = std(I);
    diffAlgebra();

    exportto(Top,R);
}


////////////////////////////////////////////////////////////////////////////////////////////////


// EXAMPLE: differential form over ring of characteristic 0
proc difform_example_1(){
    ring R = 0,(x,y,z),ds;
    diffAlgebra();

    difform df = 3*dx*x4 + (y4-y5)*dx*dy - dx*dy*dz + 1/7*dz - dx*x2*dz + 8*dy - dy*dz +12;
    
    exportto(Top,R);
    exportto(Top,df);
}


////////////////////////////////////////////////////////////////////////////////////////////////


// EXAMPLE: differential form over ring of positive characteristic
proc difform_example_2(){
    ring R = 31,(x,y,z,a,b,c),lp;
    diffAlgebra();

    difform df = -5*c4*dc*dz*dy + 3*dx*dz - 13*a4*da*db + 12*a4*da*db + x8*dx*dy + 12 + dy*da + dz*dx - (y4-y5)*x12*dx*db*dz - dx - dy + db + x2*db*dy;
    
    exportto(Top,R);
    exportto(Top,df);
}


////////////////////////////////////////////////////////////////////////////////////////////////


// EXAMPLE: differential form over quotient ring
proc difform_example_3(){
    ring S = 0,(x,y,z,t),dp;
    ideal I = xy-zt,z2t2;
    qring R = std(I);
    diffAlgebra();
    
    difform df = xy + dx*(y4+x3) - dy*dz + dx*dy*dz + z2;
    
    exportto(Top,R);
    exportto(Top,df);
}


////////////////////////////////////////////////////////////////////////////////////////////////


// EXAMPLE: differential form over quotient ring of positive characteristic
proc difform_example_4(){
    ring S = 13,(x,y,z),dp;
    ideal I = 12x4-y5,z4y3-x2,10y3x3+z4;
    qring R = std(I);
    diffAlgebra();
    
    difform df = xy + dx*(y4+x3) - dy*dz + dx*dy*dz + z2;
    
    exportto(Top,R);
    exportto(Top,df);
}


////////////////////////////////////////////////////////////////////////////////////////////////


// EXAMPLE: derivation by list
proc derivation_example_1(){
    ring R = 0,(x,y,z),lp;
    diffAlgebra();
    
    list L;
    L[1] = list(dx,dy,dz);
    L[2] = list(x,y,z);

    derivation phi = L;
    
    exportto(Top,R);
    exportto(Top,phi);    
}


////////////////////////////////////////////////////////////////////////////////////////////////


// EXAMPLE: derivation by list
proc derivation_example_2(){
    ring R = 0,(a,b,c,x,y,z),lp;
    diffAlgebra();

    list L;
    L[1] = list(dx,dy,dz,da,db,dc); 
    L[2] = list(1,12x-y,z4aby, 2*b5x,0,xyz-abc);
    derivation phi = L;

    exportto(Top,R);
    exportto(Top,phi);
}


////////////////////////////////////////////////////////////////////////////////////////////////


// EXAMPLE: derivations by list and poly
proc derivation_example_3(){
    ring R = 0,(x,y,z),dp;
    diffAlgebra();

    list L;
    L[1] = list(dx,dy,dz); 
    L[2] = list(1,x2-y,z+x);
    derivation phi_1 = L;

    L[1] = list(dx,dy,dz); 
    L[2] = list(x2,x2,z);
    derivation phi_2 = L;

    derivation phi_poly = 3x2-y;

    exportto(Top,R);
    exportto(Top,phi_1);
    exportto(Top,phi_2);
    exportto(Top,phi_poly);
}


////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////